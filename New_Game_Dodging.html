<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>純粋な弾幕回避ゲーム (ダンカグ風・精密回避)</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <style>
        body { 
            background: #2a2a2a; 
            color: white; 
            text-align: center; 
            font-family: sans-serif; 
            margin: 0; 
            padding-top: 20px; 
            padding-bottom: 50px; 
            overflow-y: auto;
        }
        h1 {
            color: #ff9800; 
            margin-bottom: 20px;
        }
        #NewGameArea {
            max-width: 600px; 
            margin: 0 auto;
            padding: 20px;
            border: 1px solid #444;
            border-radius: 8px;
            background: #1e1e1e;
        }
        #NewGameCanvas {
            /* 画面サイズは500x650のまま */
            background: #00001a;
            border: 2px solid #ff9800;
            display: block;
            margin: 20px auto;
            cursor: pointer; 
            touch-action: none; 
        }
        .back-button {
            display: inline-block;
            margin-top: 20px;
            padding: 10px 20px;
            background-color: #f44336; 
            color: white;
            text-align: center;
            text-decoration: none;
            border: 1px solid #d32f2f;
            border-radius: 5px;
            font-weight: bold;
            transition: background-color 0.1s;
        }
        .back-button:hover {
            background-color: #d32f2f;
        }
        #game-info {
            font-size: 1.2em;
            margin-bottom: 10px;
            color: #ff9800;
        }
    </style>
</head>
<body>
    <div id="NewGameArea">
        <h1>🏃 弾幕回避チャレンジ（精密芸術版）</h1>
        
        <div id="game-info">
            Time: <span id="time-display">0.00s</span> | Best: <span id="best-display">0.00s</span>
        </div>

        <canvas id="NewGameCanvas" width="500" height="650"></canvas>
        
        <a href="Iraira_Game.html" class="back-button">
            ⬅️ イライラ棒ゲームに戻る
        </a>
    </div>
    
    <script>
        const canvas = document.getElementById('NewGameCanvas');
        const ctx = canvas.getContext('2d');
        const WIDTH = canvas.width;
        const HEIGHT = canvas.height;

        // --- ゲーム状態変数 ---
        let time = 0;
        let bestTime = parseFloat(localStorage.getItem('bestTimeDodging')) || 0; 
        let keys = {};
        let player;
        let enemyBullets = [];
        let isGameOver = false;
        let gameFrame = 0;
        let isDragging = false; 
        let dragOffsetX = 0;
        let dragOffsetY = 0; 
        let starfield = []; 
        const STAR_COUNT = 100;
        const trail = []; // プレイヤーの移動トレイル用配列
        const TRAIL_LENGTH = 10;

        // --- オブジェクトクラス ---

        class Player {
            constructor() {
                this.width = 20;
                this.height = 20;
                this.x = WIDTH / 2 - this.width / 2;
                this.y = HEIGHT - this.height - 10;
                this.speed = 4.5;
                // 低速移動をさらに遅くして精密操作を可能に
                this.slowSpeed = 0.8; 
                this.color = '#00bcd4';
                this.hitRadius = 3; 
            }

            update() {
                if (isDragging) return; 

                const isSlow = keys['Shift'] || keys['z']; 
                const currentSpeed = isSlow ? this.slowSpeed : this.speed;

                // WASD/矢印キーによる移動
                if (keys['ArrowLeft'] || keys['a']) this.x -= currentSpeed;
                if (keys['ArrowRight'] || keys['d']) this.x += currentSpeed;
                if (keys['ArrowUp'] || keys['w']) this.y -= currentSpeed;
                if (keys['ArrowDown'] || keys['s']) this.y += currentSpeed;

                this.x = Math.max(0, Math.min(this.x, WIDTH - this.width));
                this.y = Math.max(0, Math.min(this.y, HEIGHT - this.height));
                
                // 低速移動時のトレイルを更新
                if (isSlow) {
                    trail.push({ x: this.getCenter().x, y: this.getCenter().y });
                    if (trail.length > TRAIL_LENGTH) {
                        trail.shift();
                    }
                } else {
                    trail.length = 0; // 低速移動を解除したらトレイルを消去
                }
            }

            draw() {
                const isSlow = keys['Shift'] || keys['z'];
                const center = this.getCenter();

                // 1. 低速移動トレイル (移動ベクトル強調)
                if (trail.length > 1) {
                    ctx.beginPath();
                    ctx.moveTo(trail[0].x, trail[0].y);
                    for (let i = 1; i < trail.length; i++) {
                        // トレイルの線が徐々に薄くなるように設定
                        ctx.strokeStyle = `rgba(0, 255, 255, ${i / TRAIL_LENGTH * 0.5})`;
                        ctx.lineWidth = 1;
                        ctx.lineTo(trail[i].x, trail[i].y);
                        ctx.stroke();
                    }
                }

                // 2. 低速時オーラ
                if (isSlow) {
                    ctx.fillStyle = 'rgba(0, 229, 255, 0.3)';
                    ctx.beginPath();
                    ctx.arc(center.x, center.y, 15, 0, Math.PI * 2);
                    ctx.fill();
                }

                // 3. プレイヤー本体
                ctx.fillStyle = isSlow ? '#00e5ff' : this.color; 
                ctx.fillRect(this.x, this.y, this.width, this.height);
                
                // 4. 当たり判定（黄色い点）
                ctx.fillStyle = isSlow ? 'yellow' : 'red';
                ctx.beginPath();
                ctx.arc(center.x, center.y, this.hitRadius + 1, 0, Math.PI * 2);
                ctx.fill();
            }

            getCenter() {
                return { 
                    x: this.x + this.width / 2, 
                    y: this.y + this.height / 2, 
                    radius: this.hitRadius 
                };
            }
        }

        // 敵弾
        class EnemyBullet {
            constructor(x, y, speed, color = 'red', dx = 0, radius = 3) {
                this.x = x;
                this.y = y;
                this.radius = radius; 
                this.speed = speed;
                this.color = color;
                this.dx = dx; 
            }

            update() {
                this.y += this.speed;
                this.x += this.dx; 
                return this.y > HEIGHT + this.radius || this.x < -this.radius || this.x > WIDTH + this.radius;
            }

            draw() {
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fill();
            }
        }
        
        // --- 背景描画関数 (変更なし) ---

        function initStarfield() {
            for (let i = 0; i < STAR_COUNT; i++) {
                starfield.push({
                    x: Math.random() * WIDTH,
                    y: Math.random() * HEIGHT,
                    size: Math.random() * 2 + 1,
                    speed: Math.random() * 0.5 + 0.1,
                    color: `rgba(255, 255, 255, ${Math.random() * 0.8 + 0.2})`
                });
            }
        }

        function drawStarfield() {
            starfield.forEach(star => {
                star.y += star.speed;
                if (star.y > HEIGHT) {
                    star.y = 0;
                    star.x = Math.random() * WIDTH;
                }
                ctx.fillStyle = star.color;
                ctx.fillRect(star.x, star.y, star.size, star.size);
            });
        }


        // --- 弾幕生成ロジック (規則的なパターンのみ) ---

        function spawnDodgingBullets() {
            const currentFrame = gameFrame;

            // ランダム弾は削除し、全て規則的なパターンに変更。

            // パターン1: 螺旋弾 (定番の規則パターン)
            if (currentFrame % 30 === 0) { 
                const num = 30; 
                const speed = 2.5;
                for (let i = 0; i < num; i++) {
                    const angle = (i * (360 / num) + currentFrame * 0.7) * (Math.PI / 180);
                    const dx = Math.cos(angle) * speed;
                    const dy = Math.sin(angle) * speed;
                    enemyBullets.push(new EnemyBullet(WIDTH / 2, 50, dy, '#ff69b4', dx));
                }
            }
            
            // パターン2: プレイヤー誘導弾 (芸術的ホーミング)
            if (currentFrame > 180 && currentFrame % 60 === 0) { 
                const targetX = player.getCenter().x;
                const targetY = player.getCenter().y;
                // 画面上部から広く発射
                const startX = WIDTH * Math.random(); 
                const startY = 0; 
                
                const angle = Math.atan2(targetY - startY, targetX - startX);
                const speed = 3.5;
                const dx = Math.cos(angle) * speed;
                const dy = Math.sin(angle) * speed;
                
                enemyBullets.push(new EnemyBullet(startX, startY, dy, '#32cd32', dx, 4)); // 少し大きめの弾
            }

            // ★ パターン3: 全方位ウェーブ弾 (周期的な回避要求)
            if (currentFrame > 300 && currentFrame % 180 === 0) { 
                const num = 18;
                const speed = 1.5;
                // 3つの波を連続して発射
                for (let wave = 0; wave < 3; wave++) {
                    const waveDelay = wave * 20; 
                    const color = wave === 0 ? '#ffffff' : wave === 1 ? '#ffff00' : '#ff00ff';

                    for (let i = 0; i < num; i++) {
                        setTimeout(() => {
                            // 角度をフレーム数によって回転させることでウェーブ効果を出す
                            const angle = (i * (360 / num) + currentFrame * 0.5 + wave * 10) * (Math.PI / 180); 
                            const dx = Math.cos(angle) * speed;
                            const dy = Math.sin(angle) * speed;
                            enemyBullets.push(new EnemyBullet(WIDTH / 2, HEIGHT / 2, dy, color, dx));
                        }, waveDelay);
                    }
                }
            }
            
            // ★ パターン4: X字/V字レーザー状弾 (ライン回避)
            if (currentFrame > 500 && currentFrame % 120 === 0) { 
                const speed = 5;
                const num = 15; 
                const colors = ['#00ffff', '#0099ff'];
                
                for (let i = 0; i < num; i++) {
                    const offset = i * 20; // 画面上部からのYオフセット
                    const delay = i * 5; // 弾の発射をずらす

                    setTimeout(() => {
                        // 左上から右下に発射 (45度)
                        enemyBullets.push(new EnemyBullet(0, offset, speed * Math.sin(45 * Math.PI / 180), colors[i % 2], speed * Math.cos(45 * Math.PI / 180)));
                        
                        // 右上から左下に発射 (135度)
                        enemyBullets.push(new EnemyBullet(WIDTH, offset, speed * Math.sin(135 * Math.PI / 180), colors[(i+1) % 2], speed * Math.cos(135 * Math.PI / 180)));

                    }, delay);
                }
            }
        }

        // --- ゲーム管理関数 (変更なし) ---

        function initGame() {
            player = new Player();
            time = 0;
            enemyBullets = [];
            isGameOver = false;
            gameFrame = 0;
            trail.length = 0;
            
            initStarfield();
            updateDisplay();
            gameLoop();
        }

        function checkCollisions() {
            if (isGameOver) return;
            
            enemyBullets = enemyBullets.filter(bullet => {
                const playerCenter = player.getCenter();
                const dist = Math.sqrt(
                    Math.pow(bullet.x - playerCenter.x, 2) + 
                    Math.pow(bullet.y - playerCenter.y, 2)
                );
                
                if (dist < bullet.radius + playerCenter.radius) {
                    gameOver();
                    return false; 
                }
                return !bullet.update(); 
            });
        }

        function gameOver() {
            isGameOver = true;
            
            if (time > bestTime) {
                bestTime = time;
                localStorage.setItem('bestTimeDodging', bestTime.toFixed(2));
            }
            
            ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
            ctx.fillRect(0, 0, WIDTH, HEIGHT);
            ctx.fillStyle = 'white';
            ctx.font = '40px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('AVOID FAILURE', WIDTH / 2, HEIGHT / 2 - 30);
            ctx.font = '24px sans-serif';
            ctx.fillText(`Survival Time: ${time.toFixed(2)}s`, WIDTH / 2, HEIGHT / 2 + 20);
            ctx.fillText('BEST RECORD: ' + bestTime.toFixed(2) + 's', WIDTH / 2, HEIGHT / 2 + 50);
            ctx.fillText('Press R to Restart', WIDTH / 2, HEIGHT / 2 + 100);
        }

        function updateDisplay() {
            document.getElementById('time-display').textContent = time.toFixed(2) + 's';
            document.getElementById('best-display').textContent = bestTime.toFixed(2) + 's';
        }

        // --- メインゲームループ ---

        function gameLoop() {
            if (isGameOver) return;
            gameFrame++; 
            ctx.textAlign = 'start';
            
            // 1. 更新
            player.update();
            spawnDodgingBullets(); 
            
            time += 1 / 60; 
            if (gameFrame % 3 === 0) { 
                updateDisplay();
            }

            checkCollisions();

            // 2. 描画
            ctx.clearRect(0, 0, WIDTH, HEIGHT); 
            ctx.fillStyle = '#00001a';
            ctx.fillRect(0, 0, WIDTH, HEIGHT);
            
            drawStarfield();
            
            player.draw();
            enemyBullets.forEach(bullet => bullet.draw());

            requestAnimationFrame(gameLoop);
        }

        // --- イベントリスナー ---
        
        window.addEventListener('keydown', (e) => {
            keys[e.key] = true;
            const key = e.key.toLowerCase();
            if (key === 'w' || key === 'a' || key === 's' || key === 'd' || key === 'shift' || key === 'z') {
                e.preventDefault(); 
            }

            if (isGameOver && key === 'r') {
                initGame(); 
                return;
            }
        });

        window.addEventListener('keyup', (e) => {
            keys[e.key] = false;
        });
        
        // --- ドラッグ/タッチ操作 ---
        function getCanvasMousePosition(event) {
            const rect = canvas.getBoundingClientRect();
            const clientX = event.touches ? event.touches[0].clientX : event.clientX;
            const clientY = event.touches ? event.touches[0].clientY : event.clientY;
            
            const x = (clientX - rect.left) * (canvas.width / rect.width);
            const y = (clientY - rect.top) * (canvas.height / rect.height);
            return { x, y };
        }

        function handleDragStart(event) {
            if (isGameOver) return;
            const pos = getCanvasMousePosition(event);
            
            dragOffsetX = pos.x - player.getCenter().x;
            dragOffsetY = pos.y - player.getCenter().y;
            
            isDragging = true;
            // タッチ操作でもキー操作による低速移動を擬似的にオンに
            keys['Shift'] = true; 
            event.preventDefault(); 
        }

        function handleDragMove(event) {
            if (!isDragging || isGameOver) return;
            const pos = getCanvasMousePosition(event);
            
            let newX = pos.x - dragOffsetX - player.width / 2;
            let newY = pos.y - dragOffsetY - player.height / 2;

            newX = Math.max(0, Math.min(newX, WIDTH - player.width));
            newY = Math.max(0, Math.min(newY, HEIGHT - player.height));
            
            player.x = newX;
            player.y = newY;
            
            event.preventDefault(); 
        }

        function handleDragEnd() {
            isDragging = false;
            // タッチ操作による低速移動を擬似的にオフに
            keys['Shift'] = false; 
        }

        // PC向けマウスイベント
        canvas.addEventListener('mousedown', handleDragStart);
        document.addEventListener('mousemove', handleDragMove);
        document.addEventListener('mouseup', handleDragEnd);

        // スマホ/タブレット向けタッチイベント
        canvas.addEventListener('touchstart', handleDragStart);
        document.addEventListener('touchmove', handleDragMove, { passive: false });
        document.addEventListener('touchend', handleDragEnd);

        // --- 初期化 ---
        initGame();

    </script>
</body>
</html>