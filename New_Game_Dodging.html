<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>ç´”ç²‹ãªå¼¾å¹•å›é¿ã‚²ãƒ¼ãƒ  (ãƒ€ãƒ³ã‚«ã‚°é¢¨ãƒ»ç²¾å¯†å›é¿)</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <style>
        body { 
            background: #2a2a2a; 
            color: white; 
            text-align: center; 
            font-family: sans-serif; 
            margin: 0; 
            padding-top: 20px; 
            padding-bottom: 50px; 
            overflow-y: auto;
        }
        h1 {
            color: #ff9800; 
            margin-bottom: 20px;
        }
        #NewGameArea {
            max-width: 600px; 
            margin: 0 auto;
            padding: 20px;
            border: 1px solid #444;
            border-radius: 8px;
            background: #1e1e1e;
        }
        #NewGameCanvas {
            /* ç”»é¢ã‚µã‚¤ã‚ºã¯500x650ã®ã¾ã¾ */
            background: #00001a;
            border: 2px solid #ff9800;
            display: block;
            margin: 20px auto;
            cursor: pointer; 
            touch-action: none; 
        }
        .back-button {
            display: inline-block;
            margin-top: 20px;
            padding: 10px 20px;
            background-color: #f44336; 
            color: white;
            text-align: center;
            text-decoration: none;
            border: 1px solid #d32f2f;
            border-radius: 5px;
            font-weight: bold;
            transition: background-color 0.1s;
        }
        .back-button:hover {
            background-color: #d32f2f;
        }
        #game-info {
            font-size: 1.2em;
            margin-bottom: 10px;
            color: #ff9800;
        }
    </style>
</head>
<body>
    <div id="NewGameArea">
        <h1>ğŸƒ å¼¾å¹•å›é¿ãƒãƒ£ãƒ¬ãƒ³ã‚¸ï¼ˆç²¾å¯†èŠ¸è¡“ç‰ˆï¼‰</h1>
        
        <div id="game-info">
            Time: <span id="time-display">0.00s</span> | Best: <span id="best-display">0.00s</span>
        </div>

        <canvas id="NewGameCanvas" width="500" height="650"></canvas>
        
        <a href="Iraira_Game.html" class="back-button">
            â¬…ï¸ ã‚¤ãƒ©ã‚¤ãƒ©æ£’ã‚²ãƒ¼ãƒ ã«æˆ»ã‚‹
        </a>
    </div>
    
    <script>
        const canvas = document.getElementById('NewGameCanvas');
        const ctx = canvas.getContext('2d');
        const WIDTH = canvas.width;
        const HEIGHT = canvas.height;

        // --- ã‚²ãƒ¼ãƒ çŠ¶æ…‹å¤‰æ•° ---
        let time = 0;
        let bestTime = parseFloat(localStorage.getItem('bestTimeDodging')) || 0; 
        let keys = {};
        let player;
        let enemyBullets = [];
        let isGameOver = false;
        let gameFrame = 0;
        let isDragging = false; 
        let dragOffsetX = 0;
        let dragOffsetY = 0; 
        let starfield = []; 
        const STAR_COUNT = 100;
        const trail = []; // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®ç§»å‹•ãƒˆãƒ¬ã‚¤ãƒ«ç”¨é…åˆ—
        const TRAIL_LENGTH = 10;

        // --- ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚¯ãƒ©ã‚¹ ---

        class Player {
            constructor() {
                this.width = 20;
                this.height = 20;
                this.x = WIDTH / 2 - this.width / 2;
                this.y = HEIGHT - this.height - 10;
                this.speed = 4.5;
                // ä½é€Ÿç§»å‹•ã‚’ã•ã‚‰ã«é…ãã—ã¦ç²¾å¯†æ“ä½œã‚’å¯èƒ½ã«
                this.slowSpeed = 0.8; 
                this.color = '#00bcd4';
                this.hitRadius = 3; 
            }

            update() {
                if (isDragging) return; 

                const isSlow = keys['Shift'] || keys['z']; 
                const currentSpeed = isSlow ? this.slowSpeed : this.speed;

                // WASD/çŸ¢å°ã‚­ãƒ¼ã«ã‚ˆã‚‹ç§»å‹•
                if (keys['ArrowLeft'] || keys['a']) this.x -= currentSpeed;
                if (keys['ArrowRight'] || keys['d']) this.x += currentSpeed;
                if (keys['ArrowUp'] || keys['w']) this.y -= currentSpeed;
                if (keys['ArrowDown'] || keys['s']) this.y += currentSpeed;

                this.x = Math.max(0, Math.min(this.x, WIDTH - this.width));
                this.y = Math.max(0, Math.min(this.y, HEIGHT - this.height));
                
                // ä½é€Ÿç§»å‹•æ™‚ã®ãƒˆãƒ¬ã‚¤ãƒ«ã‚’æ›´æ–°
                if (isSlow) {
                    trail.push({ x: this.getCenter().x, y: this.getCenter().y });
                    if (trail.length > TRAIL_LENGTH) {
                        trail.shift();
                    }
                } else {
                    trail.length = 0; // ä½é€Ÿç§»å‹•ã‚’è§£é™¤ã—ãŸã‚‰ãƒˆãƒ¬ã‚¤ãƒ«ã‚’æ¶ˆå»
                }
            }

            draw() {
                const isSlow = keys['Shift'] || keys['z'];
                const center = this.getCenter();

                // 1. ä½é€Ÿç§»å‹•ãƒˆãƒ¬ã‚¤ãƒ« (ç§»å‹•ãƒ™ã‚¯ãƒˆãƒ«å¼·èª¿)
                if (trail.length > 1) {
                    ctx.beginPath();
                    ctx.moveTo(trail[0].x, trail[0].y);
                    for (let i = 1; i < trail.length; i++) {
                        // ãƒˆãƒ¬ã‚¤ãƒ«ã®ç·šãŒå¾ã€…ã«è–„ããªã‚‹ã‚ˆã†ã«è¨­å®š
                        ctx.strokeStyle = `rgba(0, 255, 255, ${i / TRAIL_LENGTH * 0.5})`;
                        ctx.lineWidth = 1;
                        ctx.lineTo(trail[i].x, trail[i].y);
                        ctx.stroke();
                    }
                }

                // 2. ä½é€Ÿæ™‚ã‚ªãƒ¼ãƒ©
                if (isSlow) {
                    ctx.fillStyle = 'rgba(0, 229, 255, 0.3)';
                    ctx.beginPath();
                    ctx.arc(center.x, center.y, 15, 0, Math.PI * 2);
                    ctx.fill();
                }

                // 3. ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼æœ¬ä½“
                ctx.fillStyle = isSlow ? '#00e5ff' : this.color; 
                ctx.fillRect(this.x, this.y, this.width, this.height);
                
                // 4. å½“ãŸã‚Šåˆ¤å®šï¼ˆé»„è‰²ã„ç‚¹ï¼‰
                ctx.fillStyle = isSlow ? 'yellow' : 'red';
                ctx.beginPath();
                ctx.arc(center.x, center.y, this.hitRadius + 1, 0, Math.PI * 2);
                ctx.fill();
            }

            getCenter() {
                return { 
                    x: this.x + this.width / 2, 
                    y: this.y + this.height / 2, 
                    radius: this.hitRadius 
                };
            }
        }

        // æ•µå¼¾
        class EnemyBullet {
            constructor(x, y, speed, color = 'red', dx = 0, radius = 3) {
                this.x = x;
                this.y = y;
                this.radius = radius; 
                this.speed = speed;
                this.color = color;
                this.dx = dx; 
            }

            update() {
                this.y += this.speed;
                this.x += this.dx; 
                return this.y > HEIGHT + this.radius || this.x < -this.radius || this.x > WIDTH + this.radius;
            }

            draw() {
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fill();
            }
        }
        
        // --- èƒŒæ™¯æç”»é–¢æ•° (å¤‰æ›´ãªã—) ---

        function initStarfield() {
            for (let i = 0; i < STAR_COUNT; i++) {
                starfield.push({
                    x: Math.random() * WIDTH,
                    y: Math.random() * HEIGHT,
                    size: Math.random() * 2 + 1,
                    speed: Math.random() * 0.5 + 0.1,
                    color: `rgba(255, 255, 255, ${Math.random() * 0.8 + 0.2})`
                });
            }
        }

        function drawStarfield() {
            starfield.forEach(star => {
                star.y += star.speed;
                if (star.y > HEIGHT) {
                    star.y = 0;
                    star.x = Math.random() * WIDTH;
                }
                ctx.fillStyle = star.color;
                ctx.fillRect(star.x, star.y, star.size, star.size);
            });
        }


        // --- å¼¾å¹•ç”Ÿæˆãƒ­ã‚¸ãƒƒã‚¯ (è¦å‰‡çš„ãªãƒ‘ã‚¿ãƒ¼ãƒ³ã®ã¿) ---

        function spawnDodgingBullets() {
            const currentFrame = gameFrame;

            // ãƒ©ãƒ³ãƒ€ãƒ å¼¾ã¯å‰Šé™¤ã—ã€å…¨ã¦è¦å‰‡çš„ãªãƒ‘ã‚¿ãƒ¼ãƒ³ã«å¤‰æ›´ã€‚

            // ãƒ‘ã‚¿ãƒ¼ãƒ³1: èºæ—‹å¼¾ (å®šç•ªã®è¦å‰‡ãƒ‘ã‚¿ãƒ¼ãƒ³)
            if (currentFrame % 30 === 0) { 
                const num = 30; 
                const speed = 2.5;
                for (let i = 0; i < num; i++) {
                    const angle = (i * (360 / num) + currentFrame * 0.7) * (Math.PI / 180);
                    const dx = Math.cos(angle) * speed;
                    const dy = Math.sin(angle) * speed;
                    enemyBullets.push(new EnemyBullet(WIDTH / 2, 50, dy, '#ff69b4', dx));
                }
            }
            
            // ãƒ‘ã‚¿ãƒ¼ãƒ³2: ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼èª˜å°å¼¾ (èŠ¸è¡“çš„ãƒ›ãƒ¼ãƒŸãƒ³ã‚°)
            if (currentFrame > 180 && currentFrame % 60 === 0) { 
                const targetX = player.getCenter().x;
                const targetY = player.getCenter().y;
                // ç”»é¢ä¸Šéƒ¨ã‹ã‚‰åºƒãç™ºå°„
                const startX = WIDTH * Math.random(); 
                const startY = 0; 
                
                const angle = Math.atan2(targetY - startY, targetX - startX);
                const speed = 3.5;
                const dx = Math.cos(angle) * speed;
                const dy = Math.sin(angle) * speed;
                
                enemyBullets.push(new EnemyBullet(startX, startY, dy, '#32cd32', dx, 4)); // å°‘ã—å¤§ãã‚ã®å¼¾
            }

            // â˜… ãƒ‘ã‚¿ãƒ¼ãƒ³3: å…¨æ–¹ä½ã‚¦ã‚§ãƒ¼ãƒ–å¼¾ (å‘¨æœŸçš„ãªå›é¿è¦æ±‚)
            if (currentFrame > 300 && currentFrame % 180 === 0) { 
                const num = 18;
                const speed = 1.5;
                // 3ã¤ã®æ³¢ã‚’é€£ç¶šã—ã¦ç™ºå°„
                for (let wave = 0; wave < 3; wave++) {
                    const waveDelay = wave * 20; 
                    const color = wave === 0 ? '#ffffff' : wave === 1 ? '#ffff00' : '#ff00ff';

                    for (let i = 0; i < num; i++) {
                        setTimeout(() => {
                            // è§’åº¦ã‚’ãƒ•ãƒ¬ãƒ¼ãƒ æ•°ã«ã‚ˆã£ã¦å›è»¢ã•ã›ã‚‹ã“ã¨ã§ã‚¦ã‚§ãƒ¼ãƒ–åŠ¹æœã‚’å‡ºã™
                            const angle = (i * (360 / num) + currentFrame * 0.5 + wave * 10) * (Math.PI / 180); 
                            const dx = Math.cos(angle) * speed;
                            const dy = Math.sin(angle) * speed;
                            enemyBullets.push(new EnemyBullet(WIDTH / 2, HEIGHT / 2, dy, color, dx));
                        }, waveDelay);
                    }
                }
            }
            
            // â˜… ãƒ‘ã‚¿ãƒ¼ãƒ³4: Xå­—/Vå­—ãƒ¬ãƒ¼ã‚¶ãƒ¼çŠ¶å¼¾ (ãƒ©ã‚¤ãƒ³å›é¿)
            if (currentFrame > 500 && currentFrame % 120 === 0) { 
                const speed = 5;
                const num = 15; 
                const colors = ['#00ffff', '#0099ff'];
                
                for (let i = 0; i < num; i++) {
                    const offset = i * 20; // ç”»é¢ä¸Šéƒ¨ã‹ã‚‰ã®Yã‚ªãƒ•ã‚»ãƒƒãƒˆ
                    const delay = i * 5; // å¼¾ã®ç™ºå°„ã‚’ãšã‚‰ã™

                    setTimeout(() => {
                        // å·¦ä¸Šã‹ã‚‰å³ä¸‹ã«ç™ºå°„ (45åº¦)
                        enemyBullets.push(new EnemyBullet(0, offset, speed * Math.sin(45 * Math.PI / 180), colors[i % 2], speed * Math.cos(45 * Math.PI / 180)));
                        
                        // å³ä¸Šã‹ã‚‰å·¦ä¸‹ã«ç™ºå°„ (135åº¦)
                        enemyBullets.push(new EnemyBullet(WIDTH, offset, speed * Math.sin(135 * Math.PI / 180), colors[(i+1) % 2], speed * Math.cos(135 * Math.PI / 180)));

                    }, delay);
                }
            }
        }

        // --- ã‚²ãƒ¼ãƒ ç®¡ç†é–¢æ•° (å¤‰æ›´ãªã—) ---

        function initGame() {
            player = new Player();
            time = 0;
            enemyBullets = [];
            isGameOver = false;
            gameFrame = 0;
            trail.length = 0;
            
            initStarfield();
            updateDisplay();
            gameLoop();
        }

        function checkCollisions() {
            if (isGameOver) return;
            
            enemyBullets = enemyBullets.filter(bullet => {
                const playerCenter = player.getCenter();
                const dist = Math.sqrt(
                    Math.pow(bullet.x - playerCenter.x, 2) + 
                    Math.pow(bullet.y - playerCenter.y, 2)
                );
                
                if (dist < bullet.radius + playerCenter.radius) {
                    gameOver();
                    return false; 
                }
                return !bullet.update(); 
            });
        }

        function gameOver() {
            isGameOver = true;
            
            if (time > bestTime) {
                bestTime = time;
                localStorage.setItem('bestTimeDodging', bestTime.toFixed(2));
            }
            
            ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
            ctx.fillRect(0, 0, WIDTH, HEIGHT);
            ctx.fillStyle = 'white';
            ctx.font = '40px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('AVOID FAILURE', WIDTH / 2, HEIGHT / 2 - 30);
            ctx.font = '24px sans-serif';
            ctx.fillText(`Survival Time: ${time.toFixed(2)}s`, WIDTH / 2, HEIGHT / 2 + 20);
            ctx.fillText('BEST RECORD: ' + bestTime.toFixed(2) + 's', WIDTH / 2, HEIGHT / 2 + 50);
            ctx.fillText('Press R to Restart', WIDTH / 2, HEIGHT / 2 + 100);
        }

        function updateDisplay() {
            document.getElementById('time-display').textContent = time.toFixed(2) + 's';
            document.getElementById('best-display').textContent = bestTime.toFixed(2) + 's';
        }

        // --- ãƒ¡ã‚¤ãƒ³ã‚²ãƒ¼ãƒ ãƒ«ãƒ¼ãƒ— ---

        function gameLoop() {
            if (isGameOver) return;
            gameFrame++; 
            ctx.textAlign = 'start';
            
            // 1. æ›´æ–°
            player.update();
            spawnDodgingBullets(); 
            
            time += 1 / 60; 
            if (gameFrame % 3 === 0) { 
                updateDisplay();
            }

            checkCollisions();

            // 2. æç”»
            ctx.clearRect(0, 0, WIDTH, HEIGHT); 
            ctx.fillStyle = '#00001a';
            ctx.fillRect(0, 0, WIDTH, HEIGHT);
            
            drawStarfield();
            
            player.draw();
            enemyBullets.forEach(bullet => bullet.draw());

            requestAnimationFrame(gameLoop);
        }

        // --- ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ ---
        
        window.addEventListener('keydown', (e) => {
            keys[e.key] = true;
            const key = e.key.toLowerCase();
            if (key === 'w' || key === 'a' || key === 's' || key === 'd' || key === 'shift' || key === 'z') {
                e.preventDefault(); 
            }

            if (isGameOver && key === 'r') {
                initGame(); 
                return;
            }
        });

        window.addEventListener('keyup', (e) => {
            keys[e.key] = false;
        });
        
        // --- ãƒ‰ãƒ©ãƒƒã‚°/ã‚¿ãƒƒãƒæ“ä½œ ---
        function getCanvasMousePosition(event) {
            const rect = canvas.getBoundingClientRect();
            const clientX = event.touches ? event.touches[0].clientX : event.clientX;
            const clientY = event.touches ? event.touches[0].clientY : event.clientY;
            
            const x = (clientX - rect.left) * (canvas.width / rect.width);
            const y = (clientY - rect.top) * (canvas.height / rect.height);
            return { x, y };
        }

        function handleDragStart(event) {
            if (isGameOver) return;
            const pos = getCanvasMousePosition(event);
            
            dragOffsetX = pos.x - player.getCenter().x;
            dragOffsetY = pos.y - player.getCenter().y;
            
            isDragging = true;
            // ã‚¿ãƒƒãƒæ“ä½œã§ã‚‚ã‚­ãƒ¼æ“ä½œã«ã‚ˆã‚‹ä½é€Ÿç§»å‹•ã‚’æ“¬ä¼¼çš„ã«ã‚ªãƒ³ã«
            keys['Shift'] = true; 
            event.preventDefault(); 
        }

        function handleDragMove(event) {
            if (!isDragging || isGameOver) return;
            const pos = getCanvasMousePosition(event);
            
            let newX = pos.x - dragOffsetX - player.width / 2;
            let newY = pos.y - dragOffsetY - player.height / 2;

            newX = Math.max(0, Math.min(newX, WIDTH - player.width));
            newY = Math.max(0, Math.min(newY, HEIGHT - player.height));
            
            player.x = newX;
            player.y = newY;
            
            event.preventDefault(); 
        }

        function handleDragEnd() {
            isDragging = false;
            // ã‚¿ãƒƒãƒæ“ä½œã«ã‚ˆã‚‹ä½é€Ÿç§»å‹•ã‚’æ“¬ä¼¼çš„ã«ã‚ªãƒ•ã«
            keys['Shift'] = false; 
        }

        // PCå‘ã‘ãƒã‚¦ã‚¹ã‚¤ãƒ™ãƒ³ãƒˆ
        canvas.addEventListener('mousedown', handleDragStart);
        document.addEventListener('mousemove', handleDragMove);
        document.addEventListener('mouseup', handleDragEnd);

        // ã‚¹ãƒãƒ›/ã‚¿ãƒ–ãƒ¬ãƒƒãƒˆå‘ã‘ã‚¿ãƒƒãƒã‚¤ãƒ™ãƒ³ãƒˆ
        canvas.addEventListener('touchstart', handleDragStart);
        document.addEventListener('touchmove', handleDragMove, { passive: false });
        document.addEventListener('touchend', handleDragEnd);

        // --- åˆæœŸåŒ– ---
        initGame();

    </script>
</body>
</html>