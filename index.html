<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>ã‚¤ãƒ©ã‚¤ãƒ©æ£’ã‚²ãƒ¼ãƒ  (ç©¶æ¥µãƒ»å¤šæ©Ÿèƒ½ç‰ˆ)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <style>
    body {
      background: #222;
      color: white;
      text-align: center;
      font-family: sans-serif;
      margin: 0;
      padding: 0;
      transition: background-color 0.1s; /* ãƒ’ãƒƒãƒˆã‚¨ãƒ•ã‚§ã‚¯ãƒˆç”¨ */
    }
    canvas {
      background: #eee;
      display: block;
      margin: 0; 
      border: 1px solid #555;
      touch-action: none;
      transition: box-shadow 0.2s; /* ã‚´ãƒ¼ãƒ«ã‚¨ãƒ•ã‚§ã‚¯ãƒˆç”¨ */
    }
    button {
      margin: 5px;
      padding: 10px;
      cursor: pointer;
      font-size: 14px;
      background-color: #333; 
      color: white;
      border: 1px solid #777;
      line-height: 1.2;
      transition: background-color 0.1s;
    }
    
    /* ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãªãƒ¢ãƒ¼ãƒ‰ãƒœã‚¿ãƒ³ã®ã‚¹ã‚¿ã‚¤ãƒ«ã¯ä¸è¦ã«ãªã‚‹ãŒã€é€šå¸¸ãƒ¢ãƒ¼ãƒ‰ã®åˆ‡ã‚Šæ›¿ãˆã®ãŸã‚ã«æ®‹ã™ */
    .mode-button.active-mode {
        background-color: #4CAF50 !important; 
        border-color: #76FF03;
        font-weight: bold;
    }
    
    /* ãƒã‚§ãƒƒã‚¯ãƒœãƒƒã‚¯ã‚¹ã¨ãƒ©ãƒ™ãƒ«ã®ã‚¹ã‚¿ã‚¤ãƒ« */
    .mode-checkbox-container {
        display: flex;
        align-items: center;
        margin: 5px 0;
    }
    .mode-checkbox-container label {
        margin-left: 5px;
        flex-grow: 1;
        text-align: left;
        cursor: pointer;
        padding: 5px 0;
        border-radius: 3px;
        /* â˜…ãƒ¢ãƒ¼ãƒ‰åã®æŠ˜ã‚Šè¿”ã—é˜²æ­¢ */
        white-space: nowrap; 
    }
    .mode-checkbox-container input[type="checkbox"] {
        transform: scale(1.3);
        margin-right: 10px;
        cursor: pointer;
    }

    /* PC/ã‚¿ãƒ–ãƒ¬ãƒƒãƒˆå‘ã‘ã®åŸºæœ¬ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆ (1000pxä»¥ä¸Š) */
    #main-container {
        width: 1000px;
        margin: 20px auto;
        display: flex;
        justify-content: center;
        align-items: flex-start; 
    }
    #controls-left, #controls-right {
      width: 180px; 
      padding: 0 10px;
      text-align: left;
    }
    /* â˜…é›£æ˜“åº¦åã‚¿ã‚¤ãƒˆãƒ« */
    #controls-left p {
        /* é›£æ˜“åº¦åã‚¿ã‚¤ãƒˆãƒ«ã®æŠ˜ã‚Šè¿”ã—é˜²æ­¢ */
        white-space: nowrap; 
    }
    /* â˜…ãƒ¢ãƒ¼ãƒ‰åã‚¿ã‚¤ãƒˆãƒ« */
    #mode-control p, #customization-area p {
        /* ãƒ¢ãƒ¼ãƒ‰å/ã‚«ã‚¹ã‚¿ãƒã‚¤ã‚ºåã‚¿ã‚¤ãƒˆãƒ«ã®æŠ˜ã‚Šè¿”ã—é˜²æ­¢ */
        white-space: nowrap;
    }

    #game-area {
      width: 620px;
      text-align: center;
      padding: 0 10px;
    }
    /* é›£æ˜“åº¦ãƒœã‚¿ãƒ³ã‚’ç¸¦ã«ä¸¦ã¹ã‚‹ */
    #difficulty-buttons {
        display: flex;
        flex-direction: column;
        gap: 5px;
        margin-bottom: 20px;
    }
    #difficulty-buttons button {
        width: 100%;
        text-align: left;
    }

    #timer-utility-area {
        margin-bottom: 10px;
        display: flex;
        justify-content: center;
        align-items: center;
        font-size: 1.2em;
        font-weight: bold;
        /* ã‚¿ã‚¤ãƒãƒ¼è¡¨ç¤ºãŒæŠ˜ã‚Šè¿”ã•ãªã„ã‚ˆã†ã«ã™ã‚‹ */
        white-space: nowrap; 
    }
    #timer-display {
        margin-right: 15px;
    }
    #time-limit-setting {
        margin-top: 10px;
        text-align: center;
        font-size: 0.9em;
    }
    #time-limit-setting input {
        width: 60px;
        padding: 5px;
        font-size: 1em;
        margin-left: 5px;
        background: #333;
        color: white;
        border: 1px solid #777;
    }

    /* ãƒ¢ãƒ¼ãƒ‰ãƒ»ã‚«ã‚¹ã‚¿ãƒã‚¤ã‚ºã‚¨ãƒªã‚¢ */
    #mode-control, #customization-area {
        margin-top: 20px;
        padding: 10px;
        border: 1px solid #444;
        border-radius: 5px;
        background: #2a2a2a;
    }
    #mode-control { margin-top: 0; }
    #mode-control button {
        width: 100%;
        margin-bottom: 5px;
        padding: 8px;
    }
    /* é€šå¸¸ãƒ¢ãƒ¼ãƒ‰ãƒœã‚¿ãƒ³ã®ã¿ç‰¹åˆ¥æ‰±ã„ */
    #mode-normal-button {
        background-color: #555;
        font-weight: bold;
    }
    

    #customization-area button {
        margin: 3px;
        padding: 6px 10px;
    }

    /* ã‚¹ãƒãƒ¼ãƒˆãƒ•ã‚©ãƒ³å‘ã‘ã®ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆèª¿æ•´ï¼ˆç”»é¢å¹…ãŒç‹­ã„å ´åˆï¼‰ */
    @media (max-width: 1020px) {
        #main-container {
            width: 95%;
            flex-direction: column;
            align-items: center;
        }
        #controls-left, #controls-right {
            width: 90%;
            text-align: center;
            padding: 0;
            margin-bottom: 10px;
        }
        #controls-left p, #controls-right p {
             /* é›£æ˜“åº¦ãƒ»ãƒ¢ãƒ¼ãƒ‰ã‚¿ã‚¤ãƒˆãƒ«ã®è¡¨ç¤º */
            display: block; 
            text-align: center;
            /* ã‚¹ãƒãƒ›ã§æ¨ªä¸¦ã³ã«ãªã‚‹ã®ã§ã€æŠ˜ã‚Šè¿”ã—é˜²æ­¢ã¯è§£é™¤ã—ãªã„ */
        }
        #difficulty-buttons {
            flex-direction: row; 
            flex-wrap: wrap;
            justify-content: center;
            gap: 5px;
        }
        #difficulty-buttons button, #mode-control button {
             width: 45%; /* ã‚¹ãƒãƒ›ã§ã¯2åˆ—ã«ã™ã‚‹ */
             margin: 2px;
             text-align: center;
        }
        #mode-control button { width: 100%; }
        
        /* ãƒ¢ãƒ¼ãƒ‰ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«ã®é…ç½®èª¿æ•´ */
        #controls-right { order: -1; margin-bottom: 20px;}
        #controls-left { order: -2; }
    }
    
    /* å…¨ç”»é¢è¡¨ç¤ºã—ãŸéš›ã®ã‚­ãƒ£ãƒ³ãƒã‚¹ã®ã‚¹ã‚¿ã‚¤ãƒ«èª¿æ•´ï¼ˆF11å¯¾å¿œã‚‚å«ã‚€ï¼‰ */
    #game:fullscreen {
      width: 100vw;
      height: 100vh;
      margin: 0;
      border: none; 
      object-fit: contain; 
    }

    /* èª¬æ˜ãƒ¢ãƒ¼ãƒ€ãƒ«ã®ã‚¹ã‚¿ã‚¤ãƒ« */
    .modal {
        display: none; position: fixed; z-index: 100; left: 0; top: 0;
        width: 100%; height: 100%; overflow: auto; background-color: rgba(0,0,0,0.8);
    }
    .modal-content {
        background-color: #333; margin: 5% auto; padding: 20px; border: 1px solid #555;
        width: 90%; max-width: 700px; border-radius: 8px; color: white; text-align: left;
    }
    .close { color: #aaa; float: right; font-size: 28px; font-weight: bold; }
    .close:hover, .close:focus { color: white; text-decoration: none; cursor: pointer; }
    .rule-table { width: 100%; border-collapse: collapse; margin-top: 15px; }
    .rule-table th, .rule-table td { border: 1px solid #555; padding: 8px; }
    .rule-table th { background-color: #444; color: #76FF03; }
    .rule-table .gimmick-desc { font-size: 0.9em; color: #ccc;}
  </style>
</head>
<body>
  <h1>ã‚¤ãƒ©ã‚¤ãƒ©æ£’ã‚²ãƒ¼ãƒ </h1>
  
  <div id="main-container">
    
    <div id="controls-left">
        <p style="margin-top: 0; font-size: 1.1em; text-align: center;">é›£æ˜“åº¦é¸æŠ (è¿·è·¯ã‚µã‚¤ã‚º):</p>
        <div id="difficulty-buttons">
            <button onclick="setDifficulty('easy')">ç°¡å˜ (11x11)</button>
            <button onclick="setDifficulty('normal')">æ™®é€š (15x15)</button>
            <button onclick="setDifficulty('hard')">é›£ã—ã„ (21x21)</button>
            <button onclick="setDifficulty('hell')">Hell (31x31)</button>
            <button onclick="setDifficulty('super_hell')">SUPER HELL (51x51)</button>
            <button onclick="setDifficulty('ultimate_hell')">ULTIMATE HELL (71x71)</button>
            <button onclick="setDifficulty('mega_hell')">MEGA HELL (81x81)</button>
            <button onclick="setDifficulty('giga_hell')">GIGA HELL (91x91)</button>
            <button onclick="setDifficulty('tera_hell')">TERA HELL (101x101)</button>
            <button onclick="setDifficulty('peta_hell')">PETA HELL (121x121)</button>
            <button onclick="setDifficulty('exa_hell')">EXA HELL (131x131)</button>
            <button onclick="setDifficulty('zetta_hell')">ZETTA HELL (141x141)</button>
            <button onclick="setDifficulty('yotta_hell')">YOTTA HELL (151x151)</button>
            <button onclick="setDifficulty('infinity_hell')">INFINITY HELL (171x171)</button>
            <button onclick="setDifficulty('god_hell')">GOD HELL (201x201)</button>
            <button onclick="setDifficulty('brutal_hell')">**BRUTAL HELL (221x221)**</button>
            <button onclick="setDifficulty('singularity_hell')">**SINGULARITY HELL (251x251)**</button>
        </div>
    </div>
    
    <div id="game-area">
        <div id="timer-utility-area">
            <span id="timer-display">Time: 0.00s | Score: 0 | Best: --</span>
            <button onclick="resetBestTimes()">ğŸ† ãƒªã‚»ãƒƒãƒˆ</button>
            <button onclick="toggleFullScreen()">ğŸ“º å…¨ç”»é¢</button>
        </div>
        
        <canvas id="game" width="600" height="600"></canvas>
    </div>

    <div id="controls-right">
        <div id="mode-control">
            <p style="margin-top: 0; font-size: 1.1em; text-align: center;">ã‚²ãƒ¼ãƒ ãƒ¢ãƒ¼ãƒ‰é¸æŠ (è¤‡æ•°é¸æŠå¯):</p>
            
            <button id="mode-normal-button" onclick="setMode('normal')">é€šå¸¸ãƒ¢ãƒ¼ãƒ‰ (å…¨ã¦OFF)</button>

            <div class="mode-checkbox-container">
                <input type="checkbox" id="mode-ghost" onchange="resetGame(true)">
                <label for="mode-ghost">ğŸ‘» ã‚´ãƒ¼ã‚¹ãƒˆãƒ¢ãƒ¼ãƒ‰</label>
            </div>
            
            <div class="mode-checkbox-container">
                <input type="checkbox" id="mode-timeAttack" onchange="resetGame(true)">
                <label for="mode-timeAttack">â±ï¸ åˆ¶é™æ™‚é–“ãƒ¢ãƒ¼ãƒ‰</label>
            </div>
            
            <div class="mode-checkbox-container">
                <input type="checkbox" id="mode-gimmick" onchange="resetGame(true)">
                <label for="mode-gimmick">ğŸ§© ã‚®ãƒŸãƒƒã‚¯ãƒ¢ãƒ¼ãƒ‰</label>
            </div>

            <div id="time-limit-setting">
                åˆ¶é™æ™‚é–“: 
                <input type="number" id="time-limit-input" value="60" min="5" onchange="updateTimeLimit(this.value)">ç§’
            </div>
            <button onclick="document.getElementById('rule-modal').style.display = 'block';" style="margin-top: 10px; background-color: #444;">ğŸ’¡ ãƒ¢ãƒ¼ãƒ‰è©³ç´°èª¬æ˜</button>
        </div>

        <div id="customization-area">
            <p style="margin-top: 0; font-size: 1.1em; text-align: center;">ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚«ã‚¹ã‚¿ãƒã‚¤ã‚º:</p>
            <p style="margin: 5px 0 3px 0; font-size: 0.9em;">è‰²:</p>
            <button onclick="setPlayerColor('red')" style="background-color: red;">èµ¤</button>
            <button onclick="setPlayerColor('blue')" style="background-color: blue;">é’</button>
            <button onclick="setPlayerColor('yellow')" style="background-color: gold;">é»„</button>
            <p style="margin: 5px 0 3px 0; font-size: 0.9em;">å½¢:</p>
            <button onclick="setPlayerShape('square')">â–  å››è§’</button>
            <button onclick="setPlayerShape('circle')">â— ä¸¸</button>
        </div>
    </div>
  </div>

  <div id="rule-modal" class="modal">
    <div class="modal-content">
      <span class="close" onclick="document.getElementById('rule-modal').style.display = 'none';">&times;</span>
      <h2>ğŸ§© ã‚²ãƒ¼ãƒ ãƒ¢ãƒ¼ãƒ‰ã¨æ©Ÿèƒ½ã®è©³ç´°</h2>
      
      <h3>ãƒ¢ãƒ¼ãƒ‰åˆ¥è©³ç´°</h3>
      <table class="rule-table">
        <thead>
          <tr>
            <th>ãƒ¢ãƒ¼ãƒ‰å</th>
            <th>ãƒ«ãƒ¼ãƒ«</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td>**é€šå¸¸ãƒ¢ãƒ¼ãƒ‰**</td>
            <td>ç´”ç²‹ãªã‚¿ã‚¤ãƒ ã‚¢ã‚¿ãƒƒã‚¯ã€‚è¿½åŠ ã®ãƒ«ãƒ¼ãƒ«/ã‚®ãƒŸãƒƒã‚¯ãªã—ã€‚</td>
          </tr>
          <tr>
            <td>**ã‚´ãƒ¼ã‚¹ãƒˆãƒ¢ãƒ¼ãƒ‰**</td>
            <td>ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ãŒé€šã£ãŸè·¡ï¼ˆ**ç›´å‰3ãƒã‚¹**ï¼‰ãŒä¸€æ™‚çš„ãªå£ã«ãªã‚Šã¾ã™ã€‚è‡ªåˆ†ã®è»Œè·¡ã«è§¦ã‚Œã‚‹ã¨ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼ã§ã™ã€‚</td>
          </tr>
          <tr>
            <td>**åˆ¶é™æ™‚é–“ãƒ¢ãƒ¼ãƒ‰**</td>
            <td>è¨­å®šæ™‚é–“ã‹ã‚‰ã‚«ã‚¦ãƒ³ãƒˆãƒ€ã‚¦ãƒ³ã€‚æ™‚é–“åˆ‡ã‚Œï¼ˆ0ç§’ï¼‰ã«ãªã‚‹ã¨ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼ã§ã™ã€‚</td>
          </tr>
          <tr>
            <td>**ã‚®ãƒŸãƒƒã‚¯ãƒ¢ãƒ¼ãƒ‰**</td>
            <td>è¿·è·¯å†…ã«ç‰¹æ®Šãªãƒã‚¹ãŒãƒ©ãƒ³ãƒ€ãƒ ã«é…ç½®ã•ã‚Œã¾ã™ã€‚</td>
          </tr>
          <tr>
            <td colspan="2">**è¤‡åˆãƒ¢ãƒ¼ãƒ‰**</td>
          </tr>
          <tr>
            <td colspan="2" class="gimmick-desc">**è¤‡æ•°ãƒã‚§ãƒƒã‚¯ã§ãƒ«ãƒ¼ãƒ«ã‚’çµ„ã¿åˆã‚ã›ã‚‰ã‚Œã¾ã™ï¼** (ä¾‹: ã‚´ãƒ¼ã‚¹ãƒˆ + åˆ¶é™æ™‚é–“ + ã‚®ãƒŸãƒƒã‚¯)</td>
          </tr>
        </tbody>
      </table>

      <h3>ã‚®ãƒŸãƒƒã‚¯ãƒ¢ãƒ¼ãƒ‰ã§å‡ºç¾ã™ã‚‹ç‰¹æ®Šãƒã‚¹</h3>
      <table class="rule-table">
        <thead>
          <tr>
            <th>æ©Ÿèƒ½å</th>
            <th>è¦‹ãŸç›®</th>
            <th>åŠ¹æœ</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td>**ã‚¹ã‚³ã‚¢ã‚¢ã‚¤ãƒ†ãƒ **</td>
            <td><span style="color: gold;">â—ï¼ˆé»„è‰²ã„ä¸¸ï¼‰</span></td>
            <td class="gimmick-desc">é›†ã‚ã‚‹ã¨ã‚¹ã‚³ã‚¢ãŒ10ç‚¹åŠ ç®—ã•ã‚Œã¾ã™ã€‚ä¸€åº¦å–å¾—ã™ã‚‹ã¨æ¶ˆæ»…ã—ã¾ã™ã€‚</td>
          </tr>
          <tr>
            <td>**ãƒ¯ãƒ¼ãƒ—ãƒã‚¹**</td>
            <td><span style="background-color: #8a2be2; padding: 0 5px;">â– ï¼ˆç´«è‰²ï¼‰</span></td>
            <td class="gimmick-desc">è¸ã‚€ã¨ã€è¿·è·¯å†…ã®åˆ¥ã®ãƒ©ãƒ³ãƒ€ãƒ ãªé€šè·¯ãƒã‚¹ã«ç§»å‹•ã•ã›ã‚‰ã‚Œã¾ã™ã€‚</td>
          </tr>
          <tr>
            <td>**ãƒªãƒãƒ¼ã‚¹ãƒã‚¹**</td>
            <td><span style="color: deeppink;">â–¼ï¼ˆæ¿ƒã„ãƒ”ãƒ³ã‚¯ï¼‰</span></td>
            <td class="gimmick-desc">è¸ã‚€ã¨ã€æ¬¡ã®**10å›ã®ç§»å‹•æ“ä½œã®æ–¹å‘**ãŒåè»¢ã—ã¾ã™ï¼ˆä¸Šå…¥åŠ›ã§ä¸‹ã«ã€å·¦å…¥åŠ›ã§å³ã«å‹•ãï¼‰ã€‚</td>
          </tr>
          <tr>
            <td>**æ¸›é€Ÿãƒã‚¹**</td>
            <td><span style="color: aqua;">â–³ï¼ˆæ°´è‰²ï¼‰</span></td>
            <td class="gimmick-desc">è¸ã‚€ã¨ã€æ¬¡ã®**1å›ã®ç§»å‹•æ“ä½œ**ãŒã‚­ãƒ£ãƒ³ã‚»ãƒ«ã•ã‚Œã¾ã™ã€‚ä¸€æ­©è¸ã¿æã­ã‚‹ã‚¹ãƒ­ãƒ¼åŠ¹æœã§ã™ã€‚</td>
          </tr>
        </tbody>
      </table>

    </div>
  </div>

  <audio id="hitSound" src="https://actions.google.com/sounds/v1/cartoon/cartoon_boing.ogg"></audio>
  <audio id="goalSound" src="https://actions.google.com/sounds/v1/cartoon/clang_and_wobble.ogg"></audio>

  <script>
    // --- å®šæ•°ã¨ã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ•° ---
    const difficultySettings = {
      easy: 11, normal: 15, hard: 21, hell: 31, super_hell: 51,
      ultimate_hell: 71, mega_hell: 81, giga_hell: 91, tera_hell: 101,
      peta_hell: 121, exa_hell: 131, zetta_hell: 141, yotta_hell: 151,
      infinity_hell: 171, god_hell: 201,
      brutal_hell: 221, 
      singularity_hell: 251 
    };
    const CELL_TYPE = { WALL: 1, PATH: 0, SCORE: 2, WARP: 3, REVERSE: 4, SLOW: 5 };
    const BASE_SIZE = 600; 
    const TRAIL_LENGTH = 3; 
    
    let currentDifficulty = 'easy';
    let mazeSize = difficultySettings[currentDifficulty];
    let cellSize = BASE_SIZE / mazeSize; 
    let maze = [];
    let player = { x: 0, y: 0 };
    let goal = { x: mazeSize - 1, y: mazeSize - 1 };
    let timer = 0;
    let score = 0;
    let timeLimit = parseInt(localStorage.getItem('timeLimit')) || 60; 
    let bestTimes = JSON.parse(localStorage.getItem('bestTimes')) || {};
    let timerInterval;

    let activeModes = JSON.parse(localStorage.getItem('activeModes')) || {}; 
    let playerColor = localStorage.getItem('playerColor') || 'red'; 
    let playerShape = localStorage.getItem('playerShape') || 'square'; 
    let playerTrail = []; 

    let reverseMovesRemaining = 0; 
    let slowTurnActive = false; 

    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const hitSound = document.getElementById('hitSound');
    const goalSound = document.getElementById('goalSound');

    let touchStartX = 0;
    let touchStartY = 0;

    // --- UI/è¨­å®šé–¢æ•° ---

    function setPlayerColor(color) {
        playerColor = color;
        localStorage.setItem('playerColor', color);
        draw();
    }

    function setPlayerShape(shape) {
        playerShape = shape;
        localStorage.setItem('playerShape', shape);
        draw();
    }

    function updateTimeLimit(value) {
        const limit = parseInt(value);
        if (limit >= 5) {
            timeLimit = limit;
            localStorage.setItem('timeLimit', limit);
            document.getElementById('time-limit-input').value = limit;
        } else {
            document.getElementById('time-limit-input').value = 5;
            timeLimit = 5;
            localStorage.setItem('timeLimit', 5);
        }
        if (activeModes['timeAttack']) {
            resetTimer(); 
        }
    }
    
    // ãƒ¢ãƒ¼ãƒ‰è¨­å®š (ãƒã‚§ãƒƒã‚¯ãƒœãƒƒã‚¯ã‚¹ã®ON/OFFã§è¨­å®š)
    function getActiveModes() {
        const modes = {};
        modes['ghost'] = document.getElementById('mode-ghost').checked;
        modes['timeAttack'] = document.getElementById('mode-timeAttack').checked;
        modes['gimmick'] = document.getElementById('mode-gimmick').checked;
        return modes;
    }

    // é€šå¸¸ãƒ¢ãƒ¼ãƒ‰ãƒœã‚¿ãƒ³ãŒæŠ¼ã•ã‚ŒãŸã¨ã (å…¨ã¦OFFã«ã™ã‚‹)
    function setMode(mode) {
        if (mode === 'normal') {
            document.getElementById('mode-ghost').checked = false;
            document.getElementById('mode-timeAttack').checked = false;
            document.getElementById('mode-gimmick').checked = false;
        }
        resetGame(true); // ãƒ¢ãƒ¼ãƒ‰ã‚’ä¿å­˜ã—ã¦ãƒªã‚»ãƒƒãƒˆ
    }
    
    function setDifficulty(level) {
      currentDifficulty = level;
      mazeSize = difficultySettings[level];
      
      canvas.width = BASE_SIZE; 
      canvas.height = BASE_SIZE;
      cellSize = BASE_SIZE / mazeSize;
      
      // é›£æ˜“åº¦å¤‰æ›´æ™‚ã«ã‚‚ãƒ¢ãƒ¼ãƒ‰ã‚’æ›´æ–°ãƒ»ä¿å­˜ã—ã¦ã‹ã‚‰ãƒªã‚»ãƒƒãƒˆ
      resetGame(true); 
    }
    
    // åˆæœŸãƒ¢ãƒ¼ãƒ‰è¨­å®šã®åæ˜ ã¨ä¿å­˜
    function initializeModes() {
        const storedModes = JSON.parse(localStorage.getItem('activeModes')) || {};
        
        document.getElementById('mode-ghost').checked = storedModes['ghost'] || false;
        document.getElementById('mode-timeAttack').checked = storedModes['timeAttack'] || false;
        document.getElementById('mode-gimmick').checked = storedModes['gimmick'] || false;
        
        document.getElementById('time-limit-input').value = timeLimit;
    }
    
    // resetGameã‚’å‘¼ã³å‡ºã™ã¨ãã«ç¾åœ¨ã®ãƒã‚§ãƒƒã‚¯çŠ¶æ…‹ã‚’å–å¾—ãƒ»ä¿å­˜
    function resetGame(saveMode = false) {
      if (saveMode) {
          activeModes = getActiveModes();
          localStorage.setItem('activeModes', JSON.stringify(activeModes));
      } else {
          activeModes = getActiveModes(); // ãƒã‚§ãƒƒã‚¯ãƒœãƒƒã‚¯ã‚¹ã®çŠ¶æ…‹ã‚’åæ˜ 
      }

      player = { x: 0, y: 0 };
      goal = { x: mazeSize - 1, y: mazeSize - 1 };
      score = 0;
      playerTrail = [];
      // ã‚®ãƒŸãƒƒã‚¯åŠ¹æœã‚‚ãƒªã‚»ãƒƒãƒˆ
      reverseMovesRemaining = 0;
      slowTurnActive = false;
      
      generateMaze();
      
      if (!document.fullscreenElement) {
          canvas.width = BASE_SIZE; 
          canvas.height = BASE_SIZE;
          cellSize = BASE_SIZE / mazeSize;
      }
      
      draw();
      resetTimer();
    }

    function resetTimer() {
      clearInterval(timerInterval);
      
      if (activeModes['timeAttack']) {
          timer = timeLimit; 
      } else {
          timer = 0; 
      }
      updateTimerDisplay();

      timerInterval = setInterval(() => {
        if (activeModes['timeAttack']) {
            timer -= 0.01;
            if (timer <= 0) {
                timer = 0;
                clearInterval(timerInterval);
                hitEffect();
                resetGame();
                return;
            }
        } else {
            timer += 0.01;
        }
        updateTimerDisplay();
      }, 10);
    }
    
    // ãƒ™ã‚¹ãƒˆã‚¿ã‚¤ãƒ ã®ã‚­ãƒ¼ã‚’ãƒ¢ãƒ¼ãƒ‰ã®çµ„ã¿åˆã‚ã›ã«å¿œã˜ã¦ç”Ÿæˆ
    function getBestTimeKey() {
        let key = currentDifficulty;
        if (activeModes['ghost']) key += '_ghost';
        if (activeModes['timeAttack']) key += '_timeAttack';
        if (activeModes['gimmick']) key += '_gimmick';
        
        return key || currentDifficulty; 
    }
    
    function updateTimerDisplay() {
        const timeValue = (activeModes['timeAttack'] ? timer : timer).toFixed(2);
        const bestKey = getBestTimeKey();
        const bestTime = bestTimes[bestKey] || '--';
        
        const reverseText = reverseMovesRemaining > 0 ? ` (ãƒªãƒãƒ¼ã‚¹: ${reverseMovesRemaining})` : '';
        
        document.getElementById('timer-display').textContent = 
            `Time: ${timeValue}s | Score: ${score} | Best: ${bestTime}${reverseText}`;
    }

    function resetBestTimes() {
      if (confirm('å…¨ã¦ã®ãƒ™ã‚¹ãƒˆã‚¿ã‚¤ãƒ è¨˜éŒ²ã‚’ãƒªã‚»ãƒƒãƒˆã—ã¦ã‚‚ã‚ˆã‚ã—ã„ã§ã™ã‹ï¼Ÿ')) {
        localStorage.removeItem('bestTimes');
        bestTimes = {};
        updateTimerDisplay();
        alert('å…¨ã¦ã®ãƒ™ã‚¹ãƒˆã‚¿ã‚¤ãƒ è¨˜éŒ²ã‚’ãƒªã‚»ãƒƒãƒˆã—ã¾ã—ãŸã€‚');
      }
    }
    
    // --- æ¼”å‡ºé–¢æ•° ---
    function hitEffect() {
        hitSound.currentTime = 0;
        hitSound.play();
        
        // ç”»é¢ãƒ•ãƒ©ãƒƒã‚·ãƒ¥æ¼”å‡º
        document.body.style.backgroundColor = '#f00'; 
        setTimeout(() => {
            document.body.style.backgroundColor = '#222';
        }, 100);
        
        // ã‚­ãƒ£ãƒ³ãƒã‚¹æºã‚‰ã— (ç°¡æ˜“ç‰ˆ)
        canvas.style.transform = 'translate(2px, 2px)';
        setTimeout(() => {
            canvas.style.transform = 'translate(-2px, -2px)';
        }, 50);
        setTimeout(() => {
            canvas.style.transform = 'none';
        }, 100);
    }
    
    function goalEffect() {
        goalSound.play();
        
        // ã‚­ãƒ£ãƒ³ãƒã‚¹ã®å…‰ã‚‹æ¼”å‡º
        canvas.style.boxShadow = `0 0 20px 10px gold`;
        setTimeout(() => {
            canvas.style.boxShadow = `none`;
        }, 800);
    }


    // --- å…¨ç”»é¢ãƒã‚°ä¿®æ­£ãƒ­ã‚¸ãƒƒã‚¯ ---
    function toggleFullScreen() {
      const element = document.getElementById('game');
      const isFullscreen = document.fullscreenElement || document.webkitFullscreenElement || document.msFullscreenElement;

      if (!isFullscreen) {
        const requestFn = element.requestFullscreen || element.webkitRequestFullscreen || element.msRequestFullscreen;
        if (requestFn) requestFn.call(element);
        
        const updateOnFullscreen = () => {
            if (!document.fullscreenElement && !document.webkitFullscreenElement && !document.msFullscreenElement) return;

            const width = window.innerWidth;
            const height = window.innerHeight;
            const newSize = Math.min(width, height); 
            
            canvas.width = newSize;
            canvas.height = newSize;
            cellSize = newSize / mazeSize; 
            
            draw();
        };
        
        document.addEventListener('fullscreenchange', updateOnFullscreen, { once: true });
        document.addEventListener('webkitfullscreenchange', updateOnFullscreen, { once: true });
        document.addEventListener('msfullscreenchange', updateOnFullscreen, { once: true });
        
      } else {
        const exitFn = document.exitFullscreen || document.webkitExitFullscreen || document.msExitFullscreen;
        if (exitFn) exitFn.call(document);

        const restoreOnExit = () => {
            if (document.fullscreenElement || document.webkitFullscreenElement || document.msFullscreenElement) return;
            
            canvas.width = BASE_SIZE; 
            canvas.height = BASE_SIZE;
            cellSize = BASE_SIZE / mazeSize;

            canvas.style.display = 'block'; 
            canvas.offsetWidth; 
            
            draw(); 
        };
        
        document.addEventListener('fullscreenchange', restoreOnExit, { once: true });
        document.addEventListener('webkitfullscreenchange', restoreOnExit, { once: true });
        document.addEventListener('msfullscreenchange', restoreOnExit, { once: true });
      }
    }

    // --- è¿·è·¯ç”Ÿæˆ/æç”»é–¢æ•° ---

    function generateMaze() {
        maze = Array.from({ length: mazeSize }, () =>
            Array.from({ length: mazeSize }, () => CELL_TYPE.WALL)
        );

        const stack = [];
        let currentX = 0;
        let currentY = 0;
        maze[currentY][currentX] = CELL_TYPE.PATH;
        stack.push({ x: currentX, y: currentY });

        // æ£’å€’ã—æ³•ã§é€šè·¯ã‚’ç”Ÿæˆ
        while (stack.length > 0) {
            const current = stack[stack.length - 1]; 
            currentX = current.x;
            currentY = current.y;

            let directions = [ [0, -1], [0, 1], [-1, 0], [1, 0] ];
            for (let i = directions.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [directions[i], directions[j]] = [directions[j], directions[i]];
            }

            let foundNeighbor = false;
            
            for (const [dx, dy] of directions) {
                const wallX = currentX + dx;
                const wallY = currentY + dy;
                const nextX = currentX + dx * 2;
                const nextY = currentY + dy * 2;

                if (
                    nextX >= 0 && nextX < mazeSize &&
                    nextY >= 0 && nextY < mazeSize &&
                    maze[nextY][nextX] === CELL_TYPE.WALL
                ) {
                    maze[wallY][wallX] = CELL_TYPE.PATH;
                    maze[nextY][nextX] = CELL_TYPE.PATH;
                    stack.push({ x: nextX, y: nextY });
                    foundNeighbor = true;
                    break;
                }
            }

            if (!foundNeighbor) {
                stack.pop();
            }
        }
        
        // ã‚®ãƒŸãƒƒã‚¯ãƒ¢ãƒ¼ãƒ‰ã®è¨­å®š: 4ç¨®é¡ã®ã‚®ãƒŸãƒƒã‚¯ã‚’é…ç½®
        if (activeModes['gimmick']) {
            const pathCells = [];
            for (let y = 0; y < mazeSize; y++) {
                for (let x = 0; x < mazeSize; x++) {
                    // é€šè·¯ã‚»ãƒ«ã§ã€ã‚¹ã‚¿ãƒ¼ãƒˆ/ã‚´ãƒ¼ãƒ«ã§ã¯ãªã„å ´æ‰€
                    if (maze[y][x] === CELL_TYPE.PATH && (x !== 0 || y !== 0) && (x !== goal.x || y !== goal.y)) {
                        pathCells.push({x, y});
                    }
                }
            }

            // ãƒãƒƒãƒ—ã‚µã‚¤ã‚ºã«å¿œã˜ã¦ã‚®ãƒŸãƒƒã‚¯ã®æ•°ã‚’èª¿æ•´ (ä¾‹: 10x10ãƒã‚¹ã”ã¨ã«ç´„1.2å€‹)
            const numGimmicks = Math.floor(mazeSize * mazeSize / 80); 
            const gimmickTypes = [CELL_TYPE.SCORE, CELL_TYPE.WARP, CELL_TYPE.REVERSE, CELL_TYPE.SLOW];

            for(let i = 0; i < numGimmicks; i++) {
                if (pathCells.length === 0) break;
                const index = Math.floor(Math.random() * pathCells.length);
                const cell = pathCells.splice(index, 1)[0];
                
                // 4ç¨®é¡ã®ã‚®ãƒŸãƒƒã‚¯ã‹ã‚‰ãƒ©ãƒ³ãƒ€ãƒ ã«é¸æŠ
                const gimmickType = gimmickTypes[Math.floor(Math.random() * gimmickTypes.length)];
                maze[cell.y][cell.x] = gimmickType;
            }
        }
        
        maze[0][0] = CELL_TYPE.PATH;
        maze[mazeSize - 1][mazeSize - 1] = CELL_TYPE.PATH;
    }

    function draw() {
      ctx.clearRect(0, 0, canvas.width, canvas.height); 

      for (let y = 0; y < mazeSize; y++) {
        for (let x = 0; x < mazeSize; x++) {
          const cellType = maze[y][x];
          
          if (cellType === CELL_TYPE.WALL) {
            ctx.fillStyle = 'black';
            ctx.fillRect(x * cellSize, y * cellSize, cellSize, cellSize);
          } else if (cellType === CELL_TYPE.SCORE) {
            // ã‚¹ã‚³ã‚¢ã‚¢ã‚¤ãƒ†ãƒ  (é»„è‰²ã„å°ã•ãªå††)
            ctx.fillStyle = 'gold';
            const centerX = x * cellSize + cellSize / 2;
            const centerY = y * cellSize + cellSize / 2;
            ctx.beginPath();
            ctx.arc(centerX, centerY, cellSize / 3, 0, Math.PI * 2);
            ctx.fill();
          } else if (cellType === CELL_TYPE.WARP) {
            // ãƒ¯ãƒ¼ãƒ—ãƒã‚¹ (ç´«è‰²ã®ã‚°ãƒªãƒƒãƒ‰)
            ctx.fillStyle = '#8a2be2';
            ctx.fillRect(x * cellSize, y * cellSize, cellSize, cellSize);
          } else if (cellType === CELL_TYPE.REVERSE) {
            // ãƒªãƒãƒ¼ã‚¹ãƒã‚¹ (æ¿ƒã„ãƒ”ãƒ³ã‚¯ã®ä¸‰è§’)
            ctx.fillStyle = 'deeppink';
            ctx.beginPath();
            ctx.moveTo(x * cellSize + cellSize / 2, y * cellSize + cellSize * 0.2);
            ctx.lineTo(x * cellSize + cellSize * 0.8, y * cellSize + cellSize * 0.8);
            ctx.lineTo(x * cellSize + cellSize * 0.2, y * cellSize + cellSize * 0.8);
            ctx.closePath();
            ctx.fill();
          } else if (cellType === CELL_TYPE.SLOW) {
            // æ¸›é€Ÿãƒã‚¹ (æ°´è‰²ã®ä¸‰è§’)
            ctx.fillStyle = 'aqua';
            ctx.beginPath();
            ctx.moveTo(x * cellSize + cellSize * 0.2, y * cellSize + cellSize * 0.2);
            ctx.lineTo(x * cellSize + cellSize * 0.8, y * cellSize + cellSize * 0.2);
            ctx.lineTo(x * cellSize + cellSize / 2, y * cellSize + cellSize * 0.8);
            ctx.closePath();
            ctx.fill();
          }
        }
      }

      // ã‚´ãƒ¼ã‚¹ãƒˆè»Œè·¡ã®æç”» (â˜…è‰²ã‚’å¤‰æ›´ã—ã€å£ã¨ã¯ã£ãã‚ŠåŒºåˆ¥ã§ãã‚‹ã‚ˆã†ã«ã—ã¾ã—ãŸ)
      if (activeModes['ghost']) {
          playerTrail.forEach(p => {
              // è»Œè·¡ã®é€æ˜åº¦ã‚’èª¿æ•´ã—ã¦ã€ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‹ã‚‰é ã„ã»ã©è–„ãã™ã‚‹
              const alpha = 0.8 - (playerTrail.indexOf(p) / TRAIL_LENGTH) * 0.4;
              // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®èµ¤è‰²ã¨ç•°ãªã‚‹ã€ã‚ˆã‚Šæš—ã„èµ¤ã§æç”»
              ctx.fillStyle = `rgba(100, 0, 0, ${alpha})`; 
              ctx.fillRect(p.x * cellSize, p.y * cellSize, cellSize, cellSize);
          });
      }

      // ã‚´ãƒ¼ãƒ«ã®æç”»
      ctx.fillStyle = 'green';
      ctx.fillRect(goal.x * cellSize, goal.y * cellSize, cellSize, cellSize);

      // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®æç”»
      ctx.fillStyle = playerColor;
      if (playerShape === 'square') {
          ctx.fillRect(player.x * cellSize, player.y * cellSize, cellSize, cellSize);
      } else { // circle
          const centerX = player.x * cellSize + cellSize / 2;
          const centerY = player.y * cellSize + cellSize / 2;
          ctx.beginPath();
          ctx.arc(centerX, centerY, cellSize / 2, 0, Math.PI * 2);
          ctx.fill();
      }
      
      // ãƒªãƒãƒ¼ã‚¹åŠ¹æœç™ºå‹•ä¸­ã¯ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã«ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã‚’
      if (reverseMovesRemaining > 0) {
        ctx.strokeStyle = 'deeppink';
        ctx.lineWidth = 3;
        ctx.strokeRect(player.x * cellSize + 1, player.y * cellSize + 1, cellSize - 2, cellSize - 2);
      }
    }
    
    function movePlayer(dx, dy) {
      // æ¸›é€ŸåŠ¹æœãŒæœ‰åŠ¹ãªå ´åˆã€æ¬¡ã®ç§»å‹•ã‚’ã‚¹ã‚­ãƒƒãƒ—
      if (slowTurnActive) {
          slowTurnActive = false;
          draw(); 
          return; 
      }

      // ãƒªãƒãƒ¼ã‚¹åŠ¹æœã«ã‚ˆã‚‹å…¥åŠ›ã®åè»¢
      let effectiveDx = dx;
      let effectiveDy = dy;
      if (reverseMovesRemaining > 0) {
          effectiveDx *= -1;
          effectiveDy *= -1;
          reverseMovesRemaining--;
          updateTimerDisplay(); 
      }

      const newX = player.x + effectiveDx;
      const newY = player.y + effectiveDy;
      
      // ç§»å‹•å‰ä½ç½®ã®ä¿å­˜ï¼ˆç§»å‹•ãŒæˆç«‹ã™ã‚‹å ´åˆã®ã¿ï¼‰
      if (
        newX >= 0 && newX < mazeSize &&
        newY >= 0 && newY < mazeSize
      ) {
        
        // ã‚´ãƒ¼ã‚¹ãƒˆãƒ¢ãƒ¼ãƒ‰ï¼šç§»å‹•å‰ã‚’è»Œè·¡ã«è¿½åŠ 
        if (activeModes['ghost']) {
            playerTrail.push({ x: player.x, y: player.y });
            if (playerTrail.length > TRAIL_LENGTH) {
                playerTrail.shift(); // å¤ã„ã‚‚ã®ã‚’å‰Šé™¤
            }
        }

        // è¡çªåˆ¤å®š
        const isWallCollision = maze[newY][newX] === CELL_TYPE.WALL;
        const isGhostCollision = activeModes['ghost'] && playerTrail.some(p => p.x === newX && p.y === newY);

        if (isWallCollision || isGhostCollision) {
          clearInterval(timerInterval); 
          hitEffect();
          resetGame();
          return;
        }
        
        // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®ä½ç½®ã‚’æ›´æ–°
        player.x = newX;
        player.y = newY;
        
        // ã‚®ãƒŸãƒƒã‚¯å‡¦ç†
        if (activeModes['gimmick']) {
            const currentCellType = maze[player.y][player.x];
            if (currentCellType === CELL_TYPE.SCORE) {
                score += 10;
                maze[player.y][player.x] = CELL_TYPE.PATH; 
                updateTimerDisplay();
            } else if (currentCellType === CELL_TYPE.WARP) {
                maze[player.y][player.x] = CELL_TYPE.PATH; 
                
                const pathCells = [];
                for (let y = 0; y < mazeSize; y++) {
                    for (let x = 0; x < mazeSize; x++) {
                        if (maze[y][x] === CELL_TYPE.PATH && (x !== goal.x || y !== goal.y) && (x !== 0 || y !== 0)) {
                            pathCells.push({x, y});
                        }
                    }
                }
                if (pathCells.length > 0) {
                    const newPos = pathCells[Math.floor(Math.random() * pathCells.length)];
                    player.x = newPos.x;
                    player.y = newPos.y;
                }
            } else if (currentCellType === CELL_TYPE.REVERSE) {
                reverseMovesRemaining = 10; 
                maze[player.y][player.x] = CELL_TYPE.PATH;
            } else if (currentCellType === CELL_TYPE.SLOW) {
                slowTurnActive = true; 
                maze[player.y][player.x] = CELL_TYPE.PATH;
            }
        }
        
        draw();

        if (player.x === goal.x && player.y === goal.y) {
          clearInterval(timerInterval);
          goalEffect();
          
          let resultMessage = 'ã‚´ãƒ¼ãƒ«ï¼';
          const finalTime = timer.toFixed(2);
          const bestKey = getBestTimeKey();

          if (activeModes['timeAttack']) {
             resultMessage += `\næ®‹ã‚Šæ™‚é–“: ${finalTime} ç§’\nã‚¹ã‚³ã‚¢: ${score}`;
          } else {
             resultMessage += `\nã‚¯ãƒªã‚¢ã‚¿ã‚¤ãƒ : ${finalTime} ç§’\nã‚¹ã‚³ã‚¢: ${score}`;
             
             if (!bestTimes[bestKey] || finalTime < bestTimes[bestKey]) {
                bestTimes[bestKey] = finalTime;
                localStorage.setItem('bestTimes', JSON.stringify(bestTimes));
                resultMessage += '\næ–°è¨˜éŒ²é”æˆï¼';
             }
          }
          
          alert(resultMessage); 
          resetGame();
        }
      }
    }

    // --- ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ ---

    // ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰æ“ä½œ 
    document.addEventListener('keydown', (e) => {
      if (e.repeat) return; 
      
      let dx = 0, dy = 0;
      const key = e.key.toLowerCase();
      
      // çŸ¢å°ã‚­ãƒ¼
      if (e.key === 'ArrowUp') dy = -1;
      else if (e.key === 'ArrowDown') dy = 1;
      else if (e.key === 'ArrowLeft') dx = -1;
      else if (e.key === 'ArrowRight') dx = 1;
      // WASDã‚­ãƒ¼
      else if (key === 'w') dy = -1;
      else if (key === 's') dy = 1;
      else if (key === 'a') dx = -1;
      else if (key === 'd') dx = 1;
      // IJKLã‚­ãƒ¼
      else if (key === 'i') dy = -1;
      else if (key === 'k') dy = 1;
      else if (key === 'j') dx = -1;
      else if (key === 'l') dx = 1;


      if (dx === 0 && dy === 0) return;
      
      const movementKeys = ['arrowup', 'arrowdown', 'arrowleft', 'arrowright', 'w', 'a', 's', 'd', 'i', 'j', 'k', 'l'];
      if (movementKeys.includes(key)) {
        e.preventDefault();
      }
      
      movePlayer(dx, dy);
    });

    // ã‚¿ãƒƒãƒæ“ä½œ
    canvas.addEventListener('touchstart', (e) => {
        if (e.touches.length > 1) return; 
        e.preventDefault();
        touchStartX = e.touches[0].clientX;
        touchStartY = e.touches[0].clientY;
    });

    canvas.addEventListener('touchend', (e) => {
        if (!e.changedTouches.length) return; 
        
        const touchEndX = e.changedTouches[0].clientX;
        const touchEndY = e.changedTouches[0].clientY;

        const dx = touchEndX - touchStartX;
        const dy = touchEndY - touchStartY;
        
        const threshold = 15; 
        
        if (Math.abs(dx) < threshold && Math.abs(dy) < threshold) {
            return;
        }

        if (Math.abs(dx) > Math.abs(dy)) {
            if (dx > 0) movePlayer(1, 0);
            else movePlayer(-1, 0);
        } else {
            if (dy > 0) movePlayer(0, 1);
            else movePlayer(0, -1);
        }
    });

    // ãƒ¢ãƒ¼ãƒ€ãƒ«ã‚’ç”»é¢å¤–ã‚¯ãƒªãƒƒã‚¯ã§é–‰ã˜ã‚‹
    window.onclick = function(event) {
        const modal = document.getElementById('rule-modal');
        if (event.target == modal) {
            modal.style.display = "none";
        }
    }

    // --- åˆæœŸåŒ– ---
    
    // UIã‚’åˆæœŸè¨­å®šã«åˆã‚ã›ã¦æ›´æ–°
    initializeModes();
    
    // ã‚²ãƒ¼ãƒ ã®é–‹å§‹
    resetGame();
  </script>
</body>
</html>
