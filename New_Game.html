<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>å¼¾å¹•ã‚·ãƒ¥ãƒ¼ãƒ†ã‚£ãƒ³ã‚°ã‚²ãƒ¼ãƒ  (WASDãƒ»ç²¾å¯†å›é¿å¯¾å¿œ)</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <style>
        body { 
            background: #2a2a2a; 
            color: white; 
            text-align: center; 
            font-family: sans-serif; 
            margin: 0; 
            padding-top: 20px; 
            padding-bottom: 50px; 
            overflow-y: auto;
        }
        h1 {
            color: #76FF03;
            margin-bottom: 20px;
        }
        #NewGameArea {
            max-width: 600px; /* Canvasã‚µã‚¤ã‚ºã«åˆã‚ã›ã¦èª¿æ•´ */
            margin: 0 auto;
            padding: 20px;
            border: 1px solid #444;
            border-radius: 8px;
            background: #1e1e1e;
        }
        #NewGameCanvas {
            /* Canvasã‚µã‚¤ã‚ºã‚’500x650ã«çµ±ä¸€ */
            background: #00001a;
            border: 2px solid #76FF03;
            display: block;
            margin: 20px auto;
            cursor: pointer; 
            touch-action: none; 
        }
        .back-button {
            display: inline-block;
            margin-top: 20px;
            padding: 10px 20px;
            background-color: #f44336; 
            color: white;
            text-align: center;
            text-decoration: none;
            border: 1px solid #d32f2f;
            border-radius: 5px;
            font-weight: bold;
            transition: background-color 0.1s;
        }
        .back-button:hover {
            background-color: #d32f2f;
        }
        #game-info {
            font-size: 1.2em;
            margin-bottom: 10px;
            color: #76FF03;
        }
    </style>
</head>
<body>
    <div id="NewGameArea">
        <h1>ğŸŒŒ å¼¾å¹•ã‚·ãƒ¥ãƒ¼ãƒ†ã‚£ãƒ³ã‚°ï¼ˆç²¾å¯†å›é¿å¯¾å¿œï¼‰</h1>
        
        <div id="game-info">
            Score: <span id="score-display">0</span> | Lives: <span id="lives-display">3</span>
        </div>

        <canvas id="NewGameCanvas" width="500" height="650"></canvas>
        
        <a href="Iraira_Game.html" class="back-button">
            â¬…ï¸ ã‚¤ãƒ©ã‚¤ãƒ©æ£’ã‚²ãƒ¼ãƒ ã«æˆ»ã‚‹
        </a>
    </div>
    
    <script>
        const canvas = document.getElementById('NewGameCanvas');
        const ctx = canvas.getContext('2d');
        const WIDTH = canvas.width;
        const HEIGHT = canvas.height;

        // --- ã‚²ãƒ¼ãƒ çŠ¶æ…‹å¤‰æ•° ---
        let score = 0;
        let lives = 3;
        let keys = {};
        let player;
        let playerBullets = [];
        let enemies = [];
        let enemyBullets = [];
        let isGameOver = false;
        let gameFrame = 0;
        let isDragging = false; 
        let dragOffsetX = 0;
        let dragOffsetY = 0; 
        
        const trail = []; // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®ç§»å‹•ãƒˆãƒ¬ã‚¤ãƒ«ç”¨é…åˆ—
        const TRAIL_LENGTH = 10;
        const FIRE_RATE = 8; // å¼¾ã®ç™ºå°„é–“éš” (ãƒ•ãƒ¬ãƒ¼ãƒ )

        // --- ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚¯ãƒ©ã‚¹ ---

        // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ 
        class Player {
            constructor() {
                this.width = 20; // å¼¾å¹•å›é¿ã‚²ãƒ¼ãƒ ã«åˆã‚ã›ã¦å°å‹åŒ–
                this.height = 20;
                this.x = WIDTH / 2 - this.width / 2;
                this.y = HEIGHT - this.height - 10;
                this.speed = 4.5;
                this.slowSpeed = 0.8; // ä½é€Ÿç§»å‹•é€Ÿåº¦
                this.color = 'cyan';
                this.hitRadius = 3; // å½“ãŸã‚Šåˆ¤å®šã®åŠå¾„
            }

            update() {
                if (isDragging) return; 

                const isSlow = keys['Shift'] || keys['z']; 
                const currentSpeed = isSlow ? this.slowSpeed : this.speed;

                // WASDã¨çŸ¢å°ã‚­ãƒ¼ã«å¯¾å¿œ
                if (keys['ArrowLeft'] || keys['a']) this.x -= currentSpeed;
                if (keys['ArrowRight'] || keys['d']) this.x += currentSpeed;
                if (keys['ArrowUp'] || keys['w']) this.y -= currentSpeed; 
                if (keys['ArrowDown'] || keys['s']) this.y += currentSpeed; 

                // ç”»é¢å¤–ã«å‡ºãªã„ã‚ˆã†ã«åˆ¶é™
                this.x = Math.max(0, Math.min(this.x, WIDTH - this.width));
                this.y = Math.max(0, Math.min(this.y, HEIGHT - this.height));
                
                // ä½é€Ÿç§»å‹•æ™‚ã®ãƒˆãƒ¬ã‚¤ãƒ«ã‚’æ›´æ–°
                if (isSlow) {
                    trail.push({ x: this.getCenter().x, y: this.getCenter().y });
                    if (trail.length > TRAIL_LENGTH) {
                        trail.shift();
                    }
                } else {
                    trail.length = 0;
                }
            }

            draw() {
                const isSlow = keys['Shift'] || keys['z'];
                const center = this.getCenter();

                // 1. ä½é€Ÿç§»å‹•ãƒˆãƒ¬ã‚¤ãƒ«
                if (isSlow && trail.length > 1) {
                    ctx.beginPath();
                    ctx.moveTo(trail[0].x, trail[0].y);
                    for (let i = 1; i < trail.length; i++) {
                        ctx.strokeStyle = `rgba(118, 255, 3, ${i / TRAIL_LENGTH * 0.5})`; // ãƒ©ã‚¤ãƒ ã‚°ãƒªãƒ¼ãƒ³ã®ãƒˆãƒ¬ã‚¤ãƒ«
                        ctx.lineWidth = 1;
                        ctx.lineTo(trail[i].x, trail[i].y);
                        ctx.stroke();
                    }
                }
                
                // 2. ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼æœ¬ä½“ï¼ˆä¸‰è§’å½¢ï¼‰
                ctx.fillStyle = isSlow ? '#B2FF59' : this.color; 
                ctx.beginPath();
                ctx.moveTo(this.x + this.width / 2, this.y);
                ctx.lineTo(this.x, this.y + this.height);
                ctx.lineTo(this.x + this.width, this.y + this.height);
                ctx.closePath();
                ctx.fill();

                if (isSlow) {
                    ctx.strokeStyle = '#76FF03';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                }

                // 3. å½“ãŸã‚Šåˆ¤å®šï¼ˆé»„è‰²ã„ç‚¹ï¼‰
                ctx.fillStyle = isSlow ? 'yellow' : 'red';
                ctx.beginPath();
                ctx.arc(center.x, center.y, this.hitRadius + 1, 0, Math.PI * 2);
                ctx.fill();
            }

            getCenter() {
                return { x: this.x + this.width / 2, y: this.y + this.height / 2, radius: this.hitRadius };
            }
        }

        // è‡ªæ©Ÿå¼¾
        class PlayerBullet {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.radius = 3;
                this.speed = 10;
                this.color = 'yellow';
            }

            update() {
                this.y -= this.speed;
                return this.y < 0; 
            }

            draw() {
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        // æ•µ (æ¨ªç§»å‹•ã®ã¿)
        class Enemy {
            constructor(initialX, y, amplitude, frequency) {
                this.width = 30;
                this.height = 30;
                this.initialX = initialX;
                this.x = initialX;
                this.y = y; 
                this.color = 'red';
                this.amplitude = amplitude; 
                this.frequency = frequency; 
                this.fireRate = 90; 
                this.fireTimer = Math.floor(Math.random() * 90);
                this.health = 30; // ä½“åŠ›ã‚’è¨­å®š
            }

            update() {
                this.x = this.initialX + Math.sin(gameFrame * this.frequency) * this.amplitude;

                this.fireTimer++;
                if (this.fireTimer >= this.fireRate) {
                    this.fireTimer = 0;
                    this.shoot();
                }
                // ä½“åŠ›ãŒ0ã«ãªã£ãŸã‚‰trueã‚’è¿”ã—ã€å‰Šé™¤ã‚’ä¿ƒã™
                return this.health <= 0; 
            }

            shoot() {
                // æ•µå¼¾ã®ç™ºå°„ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’å°‘ã—å¼·åŒ–
                const speed = 2.5;
                for (let i = -2; i <= 2; i++) {
                    enemyBullets.push(new EnemyBullet(this.x + this.width / 2, this.y + this.height, speed, 'white', i * 0.5, 4));
                }
            }

            draw() {
                ctx.fillStyle = this.color;
                ctx.fillRect(this.x, this.y, this.width, this.height);
                
                // ä½“åŠ›ãƒãƒ¼
                ctx.fillStyle = 'lime';
                const healthWidth = (this.health / 30) * this.width;
                ctx.fillRect(this.x, this.y - 5, healthWidth, 3);
            }

            getCenter() {
                return { x: this.x + this.width / 2, y: this.y + this.height / 2, radius: this.width / 2 };
            }
        }

        // æ•µå¼¾ (å†åˆ©ç”¨)
        class EnemyBullet {
            constructor(x, y, speed, color = 'red', dx = 0, radius = 5) {
                this.x = x;
                this.y = y;
                this.radius = radius;
                this.speed = speed;
                this.color = color;
                this.dx = dx; 
            }

            update() {
                this.y += this.speed;
                this.x += this.dx; 
                return this.y > HEIGHT || this.x < 0 || this.x > WIDTH;
            }

            draw() {
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        // --- ã‚²ãƒ¼ãƒ ç®¡ç†é–¢æ•° ---

        function initGame() {
            player = new Player();
            score = 0;
            lives = 3;
            enemies = [];
            playerBullets = [];
            enemyBullets = [];
            isGameOver = false;
            gameFrame = 0;
            trail.length = 0;
            
            // æ•µã®åˆæœŸé…ç½®
            enemies.push(new Enemy(WIDTH * 0.25 - 15, 50, 50, 0.05));
            enemies.push(new Enemy(WIDTH * 0.5 - 15, 50, 10, 0.03));
            enemies.push(new Enemy(WIDTH * 0.75 - 15, 50, 50, 0.04));
            
            updateDisplay();
            gameLoop();
        }

        function checkCollisions() {
            // 1. è‡ªæ©Ÿå¼¾ vs æ•µ
            playerBullets = playerBullets.filter(bullet => {
                let hit = false;
                enemies = enemies.filter(enemy => {
                    const dist = Math.sqrt(Math.pow(bullet.x - enemy.getCenter().x, 2) + Math.pow(bullet.y - enemy.getCenter().y, 2));
                    if (dist < bullet.radius + enemy.getCenter().radius) {
                        hit = true;
                        enemy.health -= 1; // ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚’ä¸ãˆã‚‹
                        if (enemy.health <= 0) {
                            score += 100; // æ’ƒç ´ã‚¹ã‚³ã‚¢
                        } else {
                            score += 5; // ãƒ’ãƒƒãƒˆã‚¹ã‚³ã‚¢
                        }
                        return enemy.health > 0; // ä½“åŠ›ãŒæ®‹ã£ã¦ã„ãŸã‚‰é…åˆ—ã«æ®‹ã™
                    }
                    return true; 
                });
                return !hit && !bullet.update();
            });

            // 2. æ•µå¼¾ vs ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼
            if (!isGameOver) {
                enemyBullets = enemyBullets.filter(bullet => {
                    const playerCenter = player.getCenter();
                    const dist = Math.sqrt(Math.pow(bullet.x - playerCenter.x, 2) + Math.pow(bullet.y - playerCenter.y, 2));
                    
                    if (dist < bullet.radius + playerCenter.radius) {
                        lives--;
                        updateDisplay();
                        if (lives <= 0) {
                            gameOver();
                        }
                        return false; 
                    }
                    return !bullet.update(); 
                });
            }
        }
        
        // å¼¾ã®ç™ºå°„åˆ¶å¾¡
        function playerShoot() {
            if (keys[' '] || keys['x']) {
                if (gameFrame % FIRE_RATE === 0) {
                    playerBullets.push(new PlayerBullet(player.x + player.width / 2, player.y));
                }
            }
        }

        function gameOver() {
            isGameOver = true;
            ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
            ctx.fillRect(0, 0, WIDTH, HEIGHT);
            ctx.fillStyle = 'white';
            ctx.font = '40px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('GAME OVER', WIDTH / 2, HEIGHT / 2 - 30);
            ctx.font = '24px sans-serif';
            ctx.fillText(`Final Score: ${score}`, WIDTH / 2, HEIGHT / 2 + 20);
            ctx.fillText('Press R to Restart', WIDTH / 2, HEIGHT / 2 + 70);
        }

        function updateDisplay() {
            document.getElementById('score-display').textContent = score;
            document.getElementById('lives-display').textContent = lives;
        }

        // --- ãƒ¡ã‚¤ãƒ³ã‚²ãƒ¼ãƒ ãƒ«ãƒ¼ãƒ— ---

        function gameLoop() {
            if (isGameOver) return;
            gameFrame++; 
            ctx.textAlign = 'start';

            playerShoot(); // å¼¾ã®ç™ºå°„ã‚’æ›´æ–°æ™‚ã«ãƒã‚§ãƒƒã‚¯

            player.update();
            enemies = enemies.filter(enemy => !enemy.update());
            checkCollisions();

            ctx.clearRect(0, 0, WIDTH, HEIGHT); 
            ctx.fillStyle = '#00001a';
            ctx.fillRect(0, 0, WIDTH, HEIGHT);
            
            player.draw();
            playerBullets.forEach(bullet => bullet.draw());
            enemies.forEach(enemy => enemy.draw());
            enemyBullets.forEach(bullet => bullet.draw());

            requestAnimationFrame(gameLoop);
        }

        // --- ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ ---
        
        window.addEventListener('keydown', (e) => {
            keys[e.key] = true;
            const key = e.key.toLowerCase();
            // WASD/ç§»å‹•/ä½é€Ÿã‚­ãƒ¼ã®ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå‹•ä½œã‚’é˜²ã
            if (key === 'w' || key === 'a' || key === 's' || key === 'd' || key === 'shift' || key === 'z' || key === ' ') {
                e.preventDefault(); 
            }

            if (isGameOver && key === 'r') {
                initGame(); 
                return;
            }
        });

        window.addEventListener('keyup', (e) => {
            keys[e.key] = false;
        });
        
        // --- ãƒ‰ãƒ©ãƒƒã‚°/ã‚¿ãƒƒãƒæ“ä½œ (ä½é€Ÿãƒ¢ãƒ¼ãƒ‰ã®è‡ªå‹•é©ç”¨ã‚’å«ã‚€) ---
        function getCanvasMousePosition(event) {
            const rect = canvas.getBoundingClientRect();
            const clientX = event.touches ? event.touches[0].clientX : event.clientX;
            const clientY = event.touches ? event.touches[0].clientY : event.clientY;
            
            const x = (clientX - rect.left) * (canvas.width / rect.width);
            const y = (clientY - rect.top) * (canvas.height / rect.height);
            return { x, y };
        }

        function handleDragStart(event) {
            if (isGameOver) return;
            const pos = getCanvasMousePosition(event);
            
            dragOffsetX = pos.x - player.getCenter().x;
            dragOffsetY = pos.y - player.getCenter().y;
            
            isDragging = true;
            keys['Shift'] = true; // ãƒ‰ãƒ©ãƒƒã‚°ä¸­ã¯è‡ªå‹•çš„ã«ä½é€Ÿç§»å‹•ã‚’ON
            event.preventDefault(); 
        }

        function handleDragMove(event) {
            if (!isDragging || isGameOver) return;
            const pos = getCanvasMousePosition(event);
            
            let newX = pos.x - dragOffsetX - player.width / 2;
            let newY = pos.y - dragOffsetY - player.height / 2;

            newX = Math.max(0, Math.min(newX, WIDTH - player.width));
            newY = Math.max(0, Math.min(newY, HEIGHT - player.height));
            
            player.x = newX;
            player.y = newY;
            
            event.preventDefault(); 
        }

        function handleDragEnd() {
            isDragging = false;
            keys['Shift'] = false; // ãƒ‰ãƒ©ãƒƒã‚°çµ‚äº†ã§ä½é€Ÿç§»å‹•ã‚’OFF
        }

        // PCå‘ã‘ãƒã‚¦ã‚¹ã‚¤ãƒ™ãƒ³ãƒˆ
        canvas.addEventListener('mousedown', handleDragStart);
        document.addEventListener('mousemove', handleDragMove);
        document.addEventListener('mouseup', handleDragEnd);

        // ã‚¹ãƒãƒ›/ã‚¿ãƒ–ãƒ¬ãƒƒãƒˆå‘ã‘ã‚¿ãƒƒãƒã‚¤ãƒ™ãƒ³ãƒˆ
        canvas.addEventListener('touchstart', handleDragStart);
        document.addEventListener('touchmove', handleDragMove, { passive: false });
        document.addEventListener('touchend', handleDragEnd);

        // --- åˆæœŸåŒ– ---
        initGame();

    </script>
</body>
</html>