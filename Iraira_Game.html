<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>ã‚¤ãƒ©ã‚¤ãƒ©æ£’ã‚²ãƒ¼ãƒ  (ç©¶æ¥µãƒ»å¤šæ©Ÿèƒ½ç‰ˆ)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <style>
    body {
      background: #222;
      color: white;
      text-align: center;
      font-family: sans-serif;
      margin: 0;
      padding: 0;
      transition: background-color 0.1s;
    }
    canvas {
      background: #eee;
      display: block;
      margin: 0; 
      border: 1px solid #555;
      touch-action: none;
      transition: box-shadow 0.2s;
    }
    button {
      margin: 5px;
      padding: 10px;
      cursor: pointer;
      font-size: 14px;
      background-color: #333; 
      color: white;
      border: 1px solid #777;
      line-height: 1.2;
      transition: background-color 0.1s;
      text-decoration: none;
    }
    
    /* ãƒªãƒ³ã‚¯ãƒœã‚¿ãƒ³ã®ã‚¹ã‚¿ã‚¤ãƒ« */
    .link-button {
        display: block;
        width: 100%;
        margin: 10px auto; 
        padding: 15px 10px;
        background-color: #007bff;
        color: white;
        text-align: center;
        text-decoration: none;
        border: 1px solid #0056b3;
        border-radius: 5px;
        font-weight: bold;
        font-size: 1.1em;
        box-shadow: 0 4px #0056b3;
        transition: background-color 0.1s, transform 0.1s, box-shadow 0.1s;
    }
    .link-button:hover {
        background-color: #0056b3;
    }
    .link-button:active {
        transform: translateY(4px);
        box-shadow: 0 0 #0056b3;
    }

    .mode-checkbox-container {
        display: flex;
        align-items: center;
        margin: 5px 0;
    }
    .mode-checkbox-container label {
        margin-left: 5px;
        flex-grow: 1;
        text-align: left;
        cursor: pointer;
        padding: 5px 0;
        border-radius: 3px;
        white-space: nowrap; 
    }
    .mode-checkbox-container input[type="checkbox"] {
        transform: scale(1.3);
        margin-right: 10px;
        cursor: pointer;
    }

    /* PC/ã‚¿ãƒ–ãƒ¬ãƒƒãƒˆå‘ã‘ã®åŸºæœ¬ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆ (1000pxä»¥ä¸Š) */
    #main-container {
        width: 1000px;
        margin: 20px auto;
        display: flex;
        justify-content: center;
        align-items: flex-start; 
    }
    #controls-left, #controls-right {
      width: 180px; 
      padding: 0 10px;
      text-align: left;
    }

    #game-area {
      width: 620px;
      text-align: center;
      padding: 0 10px;
    }
    
    /* é›£æ˜“åº¦ãƒœã‚¿ãƒ³ã‚’ç¸¦ã«ä¸¦ã¹ã‚‹ */
    #difficulty-buttons {
        display: flex;
        flex-direction: column;
        gap: 5px;
        margin-bottom: 20px;
    }
    #difficulty-buttons button {
        width: 100%;
        text-align: left;
    }

    /* ä»¥ä¸‹ã€çœç•¥ã—ã¦ã„ãŸã‚¹ã‚¿ã‚¤ãƒ«ã¯V15ã®ã¾ã¾ */
    #timer-utility-area {
        margin-bottom: 10px;
        display: flex;
        justify-content: center;
        align-items: center;
        font-size: 1.2em;
        font-weight: bold;
        white-space: nowrap; 
    }
    #timer-display {
        margin-right: 15px;
    }

    #mode-control, #customization-area {
        margin-top: 20px;
        padding: 10px;
        border: 1px solid #444;
        border-radius: 5px;
        background: #2a2a2a;
    }
    #mode-control { margin-top: 0; }
    #mode-control button {
        width: 100%;
        margin-bottom: 5px;
        padding: 8px;
    }
    
    @media (max-width: 1020px) {
        #main-container {
            width: 95%;
            flex-direction: column;
            align-items: center;
        }
        #controls-left, #controls-right {
            width: 90%;
            text-align: center;
            padding: 0;
            margin-bottom: 10px;
        }
        #difficulty-buttons {
            flex-direction: row; 
            flex-wrap: wrap;
            justify-content: center;
            gap: 5px;
        }
        #difficulty-buttons button, #mode-control button {
             width: 45%; 
             margin: 2px;
             text-align: center;
        }
        #mode-control button { width: 100%; }
        
        #controls-right { order: -1; margin-bottom: 20px;}
        #controls-left { order: -2; }
    }
    
    #game:fullscreen {
      width: 100vw;
      height: 100vh;
      margin: 0;
      border: none; 
      object-fit: contain; 
    }

    .modal {
        display: none; position: fixed; z-index: 100; left: 0; top: 0;
        width: 100%; height: 100%; overflow: auto; background-color: rgba(0,0,0,0.8);
    }
    .modal-content {
        background-color: #333; margin: 5% auto; padding: 20px; border: 1px solid #555;
        width: 90%; max-width: 700px; border-radius: 8px; color: white; text-align: left;
    }
    .close { color: #aaa; float: right; font-size: 28px; font-weight: bold; }
    .close:hover, .close:focus { color: white; text-decoration: none; cursor: pointer; }
    .rule-table { width: 100%; border-collapse: collapse; margin-top: 15px; }
    .rule-table th, .rule-table td { border: 1px solid #555; padding: 8px; }
    .rule-table th { background-color: #444; color: #76FF03; }
    .rule-table .gimmick-desc { font-size: 0.9em; color: #ccc;}
  </style>
</head>
<body>
  <h1>ã‚¤ãƒ©ã‚¤ãƒ©æ£’ã‚²ãƒ¼ãƒ </h1>
  
  <div id="main-container">
    
    <div id="controls-left">
        
        <a href="New_Game.html" class="link-button">
            â¡ï¸ å¼¾å¹•ã‚·ãƒ¥ãƒ¼ãƒ†ã‚£ãƒ³ã‚°ã¸ï¼
        </a>
        
        <a href="New_Game_Dodging.html" class="link-button" style="background-color: #ff9800; box-shadow: 0 4px #e65100;">
            ğŸ›¡ï¸ ç´”ç²‹ãªå¼¾å¹•å›é¿ã‚²ãƒ¼ãƒ ã¸ï¼
        </a>
        <p style="margin-top: 20px; font-size: 1.1em; text-align: center;">é›£æ˜“åº¦é¸æŠ (è¿·è·¯ã‚µã‚¤ã‚º):</p>
        <div id="difficulty-buttons">
            <button onclick="setDifficulty('easy')">ç°¡å˜ (11x11)</button>
            <button onclick="setDifficulty('normal')">æ™®é€š (15x15)</button>
            <button onclick="setDifficulty('hard')">é›£ã—ã„ (21x21)</button>
            <button onclick="setDifficulty('hell')">Hell (31x31)</button>
            <button onclick="setDifficulty('super_hell')">SUPER HELL (51x51)</button>
            <button onclick="setDifficulty('ultimate_hell')">ULTIMATE HELL (71x71)</button>
            <button onclick="setDifficulty('mega_hell')">MEGA HELL (81x81)</button>
            <button onclick="setDifficulty('giga_hell')">GIGA HELL (91x91)</button>
            <button onclick="setDifficulty('tera_hell')">TERA HELL (101x101)</button>
            <button onclick="setDifficulty('peta_hell')">PETA HELL (121x121)</button>
            <button onclick="setDifficulty('exa_hell')">EXA HELL (131x131)</button>
            <button onclick="setDifficulty('zetta_hell')">ZETTA HELL (141x141)</button>
            <button onclick="setDifficulty('yotta_hell')">YOTTA HELL (151x151)</button>
            <button onclick="setDifficulty('infinity_hell')">INFINITY HELL (171x171)</button>
            <button onclick="setDifficulty('god_hell')">GOD HELL (201x201)</button>
            <button onclick="setDifficulty('brutal_hell')">**BRUTAL HELL (221x221)**</button>
            <button onclick="setDifficulty('singularity_hell')">**SINGULARITY HELL (251x251)**</button>
        </div>
    </div>
    
    <div id="game-area">
        <div id="timer-utility-area">
            <span id="timer-display">Time: 0.00s | Score: 0 | Best: --</span>
            <button onclick="resetBestTimes()">ğŸ† ãƒªã‚»ãƒƒãƒˆ</button>
            <button onclick="toggleFullScreen()">ğŸ“º å…¨ç”»é¢</button>
        </div>
        
        <canvas id="game" width="600" height="600"></canvas>
    </div>

    <div id="controls-right">
        <div id="mode-control">
            <p style="margin-top: 0; font-size: 1.1em; text-align: center;">ã‚²ãƒ¼ãƒ ãƒ¢ãƒ¼ãƒ‰é¸æŠ (è¤‡æ•°é¸æŠå¯):</p>
            
            <button id="mode-normal-button" onclick="setMode('normal')">é€šå¸¸ãƒ¢ãƒ¼ãƒ‰ (å…¨ã¦OFF)</button>

            <div class="mode-checkbox-container">
                <input type="checkbox" id="mode-ghost" onchange="resetGame(true)">
                <label for="mode-ghost">ğŸ‘» ã‚´ãƒ¼ã‚¹ãƒˆãƒ¢ãƒ¼ãƒ‰</label>
            </div>
            
            <div class="mode-checkbox-container">
                <input type="checkbox" id="mode-timeAttack" onchange="resetGame(true)">
                <label for="mode-timeAttack">â±ï¸ åˆ¶é™æ™‚é–“ãƒ¢ãƒ¼ãƒ‰</label>
            </div>
            
            <div class="mode-checkbox-container">
                <input type="checkbox" id="mode-gimmick" onchange="resetGame(true)">
                <label for="mode-gimmick">ğŸ§© ã‚®ãƒŸãƒƒã‚¯ãƒ¢ãƒ¼ãƒ‰</label>
            </div>

            <div id="time-limit-setting">
                åˆ¶é™æ™‚é–“: 
                <input type="number" id="time-limit-input" value="60" min="5" onchange="updateTimeLimit(this.value)">ç§’
            </div>
            <button onclick="document.getElementById('rule-modal').style.display = 'block';" style="margin-top: 10px; background-color: #444;">ğŸ’¡ ãƒ¢ãƒ¼ãƒ‰è©³ç´°èª¬æ˜</button>
        </div>

        <div id="customization-area">
            <p style="margin-top: 0; font-size: 1.1em; text-align: center;">ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚«ã‚¹ã‚¿ãƒã‚¤ã‚º:</p>
            <p style="margin: 5px 0 3px 0; font-size: 0.9em;">è‰²:</p>
            <button onclick="setPlayerColor('red')" style="background-color: red;">èµ¤</button>
            <button onclick="setPlayerColor('blue')" style="background-color: blue;">é’</button>
            <button onclick="setPlayerColor('yellow')" style="background-color: gold;">é»„</button>
            <p style="margin: 5px 0 3px 0; font-size: 0.9em;">å½¢:</p>
            <button onclick="setPlayerShape('square')">â–  å››è§’</button>
            <button onclick="setPlayerShape('circle')">â— ä¸¸</button>
        </div>
    </div>
  </div>

  <div id="rule-modal" class="modal">
    <div class="modal-content">
      <span class="close" onclick="document.getElementById('rule-modal').style.display = 'none';">&times;</span>
      <h2>ğŸ§© ã‚²ãƒ¼ãƒ ãƒ¢ãƒ¼ãƒ‰ã¨æ©Ÿèƒ½ã®è©³ç´°</h2>
      
      <h3>ãƒ¢ãƒ¼ãƒ‰åˆ¥è©³ç´°</h3>
      <table class="rule-table">
        <thead>
          <tr>
            <th>ãƒ¢ãƒ¼ãƒ‰å</th>
            <th>ãƒ«ãƒ¼ãƒ«</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td>**é€šå¸¸ãƒ¢ãƒ¼ãƒ‰**</td>
            <td>ç´”ç²‹ãªã‚¿ã‚¤ãƒ ã‚¢ã‚¿ãƒƒã‚¯ã€‚è¿½åŠ ã®ãƒ«ãƒ¼ãƒ«/ã‚®ãƒŸãƒƒã‚¯ãªã—ã€‚</td>
          </tr>
          <tr>
            <td>**ã‚´ãƒ¼ã‚¹ãƒˆãƒ¢ãƒ¼ãƒ‰**</td>
            <td>ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ãŒé€šã£ãŸè·¡ï¼ˆ**ç›´å‰3ãƒã‚¹**ï¼‰ãŒä¸€æ™‚çš„ãªå£ã«ãªã‚Šã¾ã™ã€‚è‡ªåˆ†ã®è»Œè·¡ã«è§¦ã‚Œã‚‹ã¨ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼ã§ã™ã€‚</td>
          </tr>
          <tr>
            <td>**åˆ¶é™æ™‚é–“ãƒ¢ãƒ¼ãƒ‰**</td>
            <td>è¨­å®šæ™‚é–“ã‹ã‚‰ã‚«ã‚¦ãƒ³ãƒˆãƒ€ã‚¦ãƒ³ã€‚æ™‚é–“åˆ‡ã‚Œï¼ˆ0ç§’ï¼‰ã«ãªã‚‹ã¨ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼ã§ã™ã€‚</td>
          </tr>
          <tr>
            <td>**ã‚®ãƒŸãƒƒã‚¯ãƒ¢ãƒ¼ãƒ‰**</td>
            <td>è¿·è·¯å†…ã«ç‰¹æ®Šãªãƒã‚¹ãŒãƒ©ãƒ³ãƒ€ãƒ ã«é…ç½®ã•ã‚Œã¾ã™ã€‚</td>
          </tr>
          <tr>
            <td colspan="2">**è¤‡åˆãƒ¢ãƒ¼ãƒ‰**</td>
          </tr>
          <tr>
            <td colspan="2" class="gimmick-desc">**è¤‡æ•°ãƒã‚§ãƒƒã‚¯ã§ãƒ«ãƒ¼ãƒ«ã‚’çµ„ã¿åˆã‚ã›ã‚‰ã‚Œã¾ã™ï¼**</td>
          </tr>
        </tbody>
      </table>

      <h3>ã‚®ãƒŸãƒƒã‚¯ãƒ¢ãƒ¼ãƒ‰ã§å‡ºç¾ã™ã‚‹ç‰¹æ®Šãƒã‚¹</h3>
      <table class="rule-table">
        <thead>
          <tr>
            <th>æ©Ÿèƒ½å</th>
            <th>è¦‹ãŸç›®</th>
            <th>åŠ¹æœ</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td>**ã‚¹ã‚³ã‚¢ã‚¢ã‚¤ãƒ†ãƒ **</td>
            <td><span style="color: gold;">â—ï¼ˆé»„è‰²ã„ä¸¸ï¼‰</span></td>
            <td class="gimmick-desc">é›†ã‚ã‚‹ã¨ã‚¹ã‚³ã‚¢ãŒ10ç‚¹åŠ ç®—ã•ã‚Œã¾ã™ã€‚</td>
          </tr>
          <tr>
            <td>**ãƒ¯ãƒ¼ãƒ—ãƒã‚¹**</td>
            <td><span style="background-color: #8a2be2; padding: 0 5px;">â– ï¼ˆç´«è‰²ï¼‰</span></td>
            <td class="gimmick-desc">è¸ã‚€ã¨ã€è¿·è·¯å†…ã®åˆ¥ã®ãƒ©ãƒ³ãƒ€ãƒ ãªé€šè·¯ãƒã‚¹ã«ç§»å‹•ã•ã›ã‚‰ã‚Œã¾ã™ã€‚</td>
          </tr>
          <tr>
            <td>**ãƒªãƒãƒ¼ã‚¹ãƒã‚¹**</td>
            <td><span style="color: deeppink;">â–¼ï¼ˆæ¿ƒã„ãƒ”ãƒ³ã‚¯ï¼‰</span></td>
            <td class="gimmick-desc">è¸ã‚€ã¨ã€æ¬¡ã®**10å›ã®ç§»å‹•æ“ä½œã®æ–¹å‘**ãŒåè»¢ã—ã¾ã™ã€‚</td>
          </tr>
          <tr>
            <td>**æ¸›é€Ÿãƒã‚¹**</td>
            <td><span style="color: aqua;">â–³ï¼ˆæ°´è‰²ï¼‰</span></td>
            <td class="gimmick-desc">è¸ã‚€ã¨ã€æ¬¡ã®**1å›ã®ç§»å‹•æ“ä½œ**ãŒã‚­ãƒ£ãƒ³ã‚»ãƒ«ã•ã‚Œã¾ã™ã€‚</td>
          </tr>
        </tbody>
      </table>

    </div>
  </div>

  <audio id="hitSound" src="https://actions.google.com/sounds/v1/cartoon/cartoon_boing.ogg"></audio>
  <audio id="goalSound" src="https://actions.google.com/sounds/v1/cartoon/clang_and_wobble.ogg"></audio>

  <script>
    // --- ã‚¤ãƒ©ã‚¤ãƒ©æ£’ã‚²ãƒ¼ãƒ ã®JavaScriptã‚³ãƒ¼ãƒ‰ (çœç•¥ã›ãšã«å…¨è¨˜è¿°) ---
    const difficultySettings = {
      easy: 11, normal: 15, hard: 21, hell: 31, super_hell: 51,
      ultimate_hell: 71, mega_hell: 81, giga_hell: 91, tera_hell: 101,
      peta_hell: 121, exa_hell: 131, zetta_hell: 141, yotta_hell: 151,
      infinity_hell: 171, god_hell: 201,
      brutal_hell: 221, 
      singularity_hell: 251 
    };
    const CELL_TYPE = { WALL: 1, PATH: 0, SCORE: 2, WARP: 3, REVERSE: 4, SLOW: 5 };
    const BASE_SIZE = 600; 
    const TRAIL_LENGTH = 3; 
    
    let currentDifficulty = 'easy';
    let mazeSize = difficultySettings[currentDifficulty];
    let cellSize = BASE_SIZE / mazeSize; 
    let maze = [];
    let player = { x: 0, y: 0 };
    let goal = { x: mazeSize - 1, y: mazeSize - 1 };
    let timer = 0;
    let score = 0;
    let timeLimit = parseInt(localStorage.getItem('timeLimit')) || 60; 
    let bestTimes = JSON.parse(localStorage.getItem('bestTimes')) || {};
    let timerInterval;

    let activeModes = JSON.parse(localStorage.getItem('activeModes')) || {}; 
    let playerColor = localStorage.getItem('playerColor') || 'red'; 
    let playerShape = localStorage.getItem('playerShape') || 'square'; 
    let playerTrail = []; 

    let reverseMovesRemaining = 0; 
    let slowTurnActive = false; 

    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const hitSound = document.getElementById('hitSound');
    const goalSound = document.getElementById('goalSound');

    let touchStartX = 0;
    let touchStartY = 0;

    // --- UI/è¨­å®šé–¢æ•° ---

    function setPlayerColor(color) {
        playerColor = color;
        localStorage.setItem('playerColor', color);
        draw();
    }

    function setPlayerShape(shape) {
        playerShape = shape;
        localStorage.setItem('playerShape', shape);
        draw();
    }

    function updateTimeLimit(value) {
        const limit = parseInt(value);
        if (limit >= 5) {
            timeLimit = limit;
            localStorage.setItem('timeLimit', limit);
            document.getElementById('time-limit-input').value = limit;
        } else {
            document.getElementById('time-limit-input').value = 5;
            timeLimit = 5;
            localStorage.setItem('timeLimit', 5);
        }
        if (activeModes['timeAttack']) {
            resetTimer(); 
        }
    }
    
    function getActiveModes() {
        const modes = {};
        modes['ghost'] = document.getElementById('mode-ghost').checked;
        modes['timeAttack'] = document.getElementById('mode-timeAttack').checked;
        modes['gimmick'] = document.getElementById('mode-gimmick').checked;
        return modes;
    }

    function setMode(mode) {
        if (mode === 'normal') {
            document.getElementById('mode-ghost').checked = false;
            document.getElementById('mode-timeAttack').checked = false;
            document.getElementById('mode-gimmick').checked = false;
        }
        resetGame(true); 
    }
    
    function setDifficulty(level) {
      currentDifficulty = level;
      mazeSize = difficultySettings[level];
      
      canvas.width = BASE_SIZE; 
      canvas.height = BASE_SIZE;
      cellSize = BASE_SIZE / mazeSize;
      
      resetGame(true); 
    }
    
    function initializeModes() {
        const storedModes = JSON.parse(localStorage.getItem('activeModes')) || {};
        
        document.getElementById('mode-ghost').checked = storedModes['ghost'] || false;
        document.getElementById('mode-timeAttack').checked = storedModes['timeAttack'] || false;
        document.getElementById('mode-gimmick').checked = storedModes['gimmick'] || false;
        
        document.getElementById('time-limit-input').value = timeLimit;
    }
    
    function resetGame(saveMode = false) {
      if (saveMode) {
          activeModes = getActiveModes();
          localStorage.setItem('activeModes', JSON.stringify(activeModes));
      } else {
          activeModes = getActiveModes(); 
      }

      player = { x: 0, y: 0 };
      goal = { x: mazeSize - 1, y: mazeSize - 1 };
      score = 0;
      playerTrail = [];
      reverseMovesRemaining = 0;
      slowTurnActive = false;
      
      generateMaze();
      
      if (!document.fullscreenElement) {
          canvas.width = BASE_SIZE; 
          canvas.height = BASE_SIZE;
          cellSize = BASE_SIZE / mazeSize;
      }
      
      draw();
      resetTimer();
    }

    function resetTimer() {
      clearInterval(timerInterval);
      
      if (activeModes['timeAttack']) {
          timer = timeLimit; 
      } else {
          timer = 0; 
      }
      updateTimerDisplay();

      timerInterval = setInterval(() => {
        if (activeModes['timeAttack']) {
            timer -= 0.01;
            if (timer <= 0) {
                timer = 0;
                clearInterval(timerInterval);
                hitEffect();
                resetGame();
                return;
            }
        } else {
            timer += 0.01;
        }
        updateTimerDisplay();
      }, 10);
    }
    
    function getBestTimeKey() {
        let key = currentDifficulty;
        if (activeModes['ghost']) key += '_ghost';
        if (activeModes['timeAttack']) key += '_timeAttack';
        if (activeModes['gimmick']) key += '_gimmick';
        
        return key || currentDifficulty; 
    }
    
    function updateTimerDisplay() {
        const timeValue = (activeModes['timeAttack'] ? timer : timer).toFixed(2);
        const bestKey = getBestTimeKey();
        const bestTime = bestTimes[bestKey] || '--';
        
        const reverseText = reverseMovesRemaining > 0 ? ` (ãƒªãƒãƒ¼ã‚¹: ${reverseMovesRemaining})` : '';
        
        document.getElementById('timer-display').textContent = 
            `Time: ${timeValue}s | Score: ${score} | Best: ${bestTime}${reverseText}`;
    }

    function resetBestTimes() {
      if (confirm('å…¨ã¦ã®ãƒ™ã‚¹ãƒˆã‚¿ã‚¤ãƒ è¨˜éŒ²ã‚’ãƒªã‚»ãƒƒãƒˆã—ã¦ã‚‚ã‚ˆã‚ã—ã„ã§ã™ã‹ï¼Ÿ')) {
        localStorage.removeItem('bestTimes');
        bestTimes = {};
        updateTimerDisplay();
        alert('å…¨ã¦ã®ãƒ™ã‚¹ãƒˆã‚¿ã‚¤ãƒ è¨˜éŒ²ã‚’ãƒªã‚»ãƒƒãƒˆã—ã¾ã—ãŸã€‚');
      }
    }
    
    function hitEffect() {
        hitSound.currentTime = 0;
        hitSound.play();
        document.body.style.backgroundColor = '#f00'; 
        setTimeout(() => {
            document.body.style.backgroundColor = '#222';
        }, 100);
        canvas.style.transform = 'translate(2px, 2px)';
        setTimeout(() => {
            canvas.style.transform = 'translate(-2px, -2px)';
        }, 50);
        setTimeout(() => {
            canvas.style.transform = 'none';
        }, 100);
    }
    
    function goalEffect() {
        goalSound.play();
        canvas.style.boxShadow = `0 0 20px 10px gold`;
        setTimeout(() => {
            canvas.style.boxShadow = `none`;
        }, 800);
    }


    function toggleFullScreen() {
      const element = document.getElementById('game');
      const isFullscreen = document.fullscreenElement || document.webkitFullscreenElement || document.msFullscreenElement;

      if (!isFullscreen) {
        const requestFn = element.requestFullscreen || element.webkitRequestFullscreen || element.msRequestFullscreen;
        if (requestFn) requestFn.call(element);
        
        const updateOnFullscreen = () => {
            if (!document.fullscreenElement && !document.webkitFullscreenElement && !document.msFullscreenElement) return;

            const width = window.innerWidth;
            const height = window.innerHeight;
            const newSize = Math.min(width, height); 
            
            canvas.width = newSize;
            canvas.height = newSize;
            cellSize = newSize / mazeSize; 
            
            draw();
        };
        
        document.addEventListener('fullscreenchange', updateOnFullscreen, { once: true });
        document.addEventListener('webkitfullscreenchange', updateOnFullscreen, { once: true });
        document.addEventListener('msfullscreenchange', updateOnFullscreen, { once: true });
        
      } else {
        const exitFn = document.exitFullscreen || document.webkitExitFullscreen || document.msExitFullscreen;
        if (exitFn) exitFn.call(document);

        const restoreOnExit = () => {
            if (document.fullscreenElement || document.webkitFullscreenElement || document.msFullscreenElement) return;
            
            canvas.width = BASE_SIZE; 
            canvas.height = BASE_SIZE;
            cellSize = BASE_SIZE / mazeSize;

            canvas.style.display = 'block'; 
            canvas.offsetWidth; 
            
            draw(); 
        };
        
        document.addEventListener('fullscreenchange', restoreOnExit, { once: true });
        document.addEventListener('webkitfullscreenchange', restoreOnExit, { once: true });
        document.addEventListener('msfullscreenchange', restoreOnExit, { once: true });
      }
    }

    function generateMaze() {
        maze = Array.from({ length: mazeSize }, () =>
            Array.from({ length: mazeSize }, () => CELL_TYPE.WALL)
        );

        const stack = [];
        let currentX = 0;
        let currentY = 0;
        maze[currentY][currentX] = CELL_TYPE.PATH;
        stack.push({ x: currentX, y: currentY });

        while (stack.length > 0) {
            const current = stack[stack.length - 1]; 
            currentX = current.x;
            currentY = current.y;

            let directions = [ [0, -1], [0, 1], [-1, 0], [1, 0] ];
            for (let i = directions.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [directions[i], directions[j]] = [directions[j], directions[i]];
            }

            let foundNeighbor = false;
            
            for (const [dx, dy] of directions) {
                const wallX = currentX + dx;
                const wallY = currentY + dy;
                const nextX = currentX + dx * 2;
                const nextY = currentY + dy * 2;

                if (
                    nextX >= 0 && nextX < mazeSize &&
                    nextY >= 0 && nextY < mazeSize &&
                    maze[nextY][nextX] === CELL_TYPE.WALL
                ) {
                    maze[wallY][wallX] = CELL_TYPE.PATH;
                    maze[nextY][nextX] = CELL_TYPE.PATH;
                    stack.push({ x: nextX, y: nextY });
                    foundNeighbor = true;
                    break;
                }
            }

            if (!foundNeighbor) {
                stack.pop();
            }
        }
        
        if (activeModes['gimmick']) {
            const pathCells = [];
            for (let y = 0; y < mazeSize; y++) {
                for (let x = 0; x < mazeSize; x++) {
                    if (maze[y][x] === CELL_TYPE.PATH && (x !== 0 || y !== 0) && (x !== goal.x || y !== goal.y)) {
                        pathCells.push({x, y});
                    }
                }
            }

            const numGimmicks = Math.floor(mazeSize * mazeSize / 80); 
            const gimmickTypes = [CELL_TYPE.SCORE, CELL_TYPE.WARP, CELL_TYPE.REVERSE, CELL_TYPE.SLOW];

            for(let i = 0; i < numGimmicks; i++) {
                if (pathCells.length === 0) break;
                const index = Math.floor(Math.random() * pathCells.length);
                const cell = pathCells.splice(index, 1)[0];
                
                const gimmickType = gimmickTypes[Math.floor(Math.random() * gimmickTypes.length)];
                maze[cell.y][cell.x] = gimmickType;
            }
        }
        
        maze[0][0] = CELL_TYPE.PATH;
        maze[mazeSize - 1][mazeSize - 1] = CELL_TYPE.PATH;
    }

    function draw() {
      ctx.clearRect(0, 0, canvas.width, canvas.height); 

      for (let y = 0; y < mazeSize; y++) {
        for (let x = 0; x < mazeSize; x++) {
          const cellType = maze[y][x];
          
          if (cellType === CELL_TYPE.WALL) {
            ctx.fillStyle = 'black';
            ctx.fillRect(x * cellSize, y * cellSize, cellSize, cellSize);
          } else if (cellType === CELL_TYPE.SCORE) {
            ctx.fillStyle = 'gold';
            const centerX = x * cellSize + cellSize / 2;
            const centerY = y * cellSize + cellSize / 2;
            ctx.beginPath();
            ctx.arc(centerX, centerY, cellSize / 3, 0, Math.PI * 2);
            ctx.fill();
          } else if (cellType === CELL_TYPE.WARP) {
            ctx.fillStyle = '#8a2be2';
            ctx.fillRect(x * cellSize, y * cellSize, cellSize, cellSize);
          } else if (cellType === CELL_TYPE.REVERSE) {
            ctx.fillStyle = 'deeppink';
            ctx.beginPath();
            ctx.moveTo(x * cellSize + cellSize / 2, y * cellSize + cellSize * 0.2);
            ctx.lineTo(x * cellSize + cellSize * 0.8, y * cellSize + cellSize * 0.8);
            ctx.lineTo(x * cellSize + cellSize * 0.2, y * cellSize + cellSize * 0.8);
            ctx.closePath();
            ctx.fill();
          } else if (cellType === CELL_TYPE.SLOW) {
            ctx.fillStyle = 'aqua';
            ctx.beginPath();
            ctx.moveTo(x * cellSize + cellSize * 0.2, y * cellSize + cellSize * 0.2);
            ctx.lineTo(x * cellSize + cellSize * 0.8, y * cellSize + cellSize * 0.2);
            ctx.lineTo(x * cellSize + cellSize / 2, y * cellSize + cellSize * 0.8);
            ctx.closePath();
            ctx.fill();
          }
        }
      }

      if (activeModes['ghost']) {
          playerTrail.forEach(p => {
              const alpha = 0.8 - (playerTrail.indexOf(p) / TRAIL_LENGTH) * 0.4;
              ctx.fillStyle = `rgba(100, 0, 0, ${alpha})`; 
              ctx.fillRect(p.x * cellSize, p.y * cellSize, cellSize, cellSize);
          });
      }

      ctx.fillStyle = 'green';
      ctx.fillRect(goal.x * cellSize, goal.y * cellSize, cellSize, cellSize);

      ctx.fillStyle = playerColor;
      if (playerShape === 'square') {
          ctx.fillRect(player.x * cellSize, player.y * cellSize, cellSize, cellSize);
      } else { 
          const centerX = player.x * cellSize + cellSize / 2;
          const centerY = player.y * cellSize + cellSize / 2;
          ctx.beginPath();
          ctx.arc(centerX, centerY, cellSize / 2, 0, Math.PI * 2);
          ctx.fill();
      }
      
      if (reverseMovesRemaining > 0) {
        ctx.strokeStyle = 'deeppink';
        ctx.lineWidth = 3;
        ctx.strokeRect(player.x * cellSize + 1, player.y * cellSize + 1, cellSize - 2, cellSize - 2);
      }
    }
    
    function movePlayer(dx, dy) {
      if (slowTurnActive) {
          slowTurnActive = false;
          draw(); 
          return; 
      }

      let effectiveDx = dx;
      let effectiveDy = dy;
      if (reverseMovesRemaining > 0) {
          effectiveDx *= -1;
          effectiveDy *= -1;
          reverseMovesRemaining--;
          updateTimerDisplay(); 
      }

      const newX = player.x + effectiveDx;
      const newY = player.y + effectiveDy;
      
      if (
        newX >= 0 && newX < mazeSize &&
        newY >= 0 && newY < mazeSize
      ) {
        
        if (activeModes['ghost']) {
            playerTrail.push({ x: player.x, y: player.y });
            if (playerTrail.length > TRAIL_LENGTH) {
                playerTrail.shift(); 
            }
        }

        const isWallCollision = maze[newY][newX] === CELL_TYPE.WALL;
        const isGhostCollision = activeModes['ghost'] && playerTrail.some(p => p.x === newX && p.y === newY);

        if (isWallCollision || isGhostCollision) {
          clearInterval(timerInterval); 
          hitEffect();
          resetGame();
          return;
        }
        
        player.x = newX;
        player.y = newY;
        
        if (activeModes['gimmick']) {
            const currentCellType = maze[player.y][player.x];
            if (currentCellType === CELL_TYPE.SCORE) {
                score += 10;
                maze[player.y][player.x] = CELL_TYPE.PATH; 
                updateTimerDisplay();
            } else if (currentCellType === CELL_TYPE.WARP) {
                maze[player.y][player.x] = CELL_TYPE.PATH; 
                
                const pathCells = [];
                for (let y = 0; y < mazeSize; y++) {
                    for (let x = 0; x < mazeSize; x++) {
                        if (maze[y][x] === CELL_TYPE.PATH && (x !== goal.x || y !== goal.y) && (x !== 0 || y !== 0)) {
                            pathCells.push({x, y});
                        }
                    }
                }
                if (pathCells.length > 0) {
                    const newPos = pathCells[Math.floor(Math.random() * pathCells.length)];
                    player.x = newPos.x;
                    player.y = newPos.y;
                }
            } else if (currentCellType === CELL_TYPE.REVERSE) {
                reverseMovesRemaining = 10; 
                maze[player.y][player.x] = CELL_TYPE.PATH;
            } else if (currentCellType === CELL_TYPE.SLOW) {
                slowTurnActive = true; 
                maze[player.y][player.x] = CELL_TYPE.PATH;
            }
        }
        
        draw();

        if (player.x === goal.x && player.y === goal.y) {
          clearInterval(timerInterval);
          goalEffect();
          
          let resultMessage = 'ã‚´ãƒ¼ãƒ«ï¼';
          const finalTime = timer.toFixed(2);
          const bestKey = getBestTimeKey();

          if (activeModes['timeAttack']) {
             resultMessage += `\næ®‹ã‚Šæ™‚é–“: ${finalTime} ç§’\nã‚¹ã‚³ã‚¢: ${score}`;
          } else {
             resultMessage += `\nã‚¯ãƒªã‚¢ã‚¿ã‚¤ãƒ : ${finalTime} ç§’\nã‚¹ã‚³ã‚¢: ${score}`;
             
             if (!bestTimes[bestKey] || finalTime < bestTimes[bestKey]) {
                bestTimes[bestKey] = finalTime;
                localStorage.setItem('bestTimes', JSON.stringify(bestTimes));
                resultMessage += '\næ–°è¨˜éŒ²é”æˆï¼';
             }
          }
          
          alert(resultMessage); 
          resetGame();
        }
      }
    }

    // --- ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ ---
    document.addEventListener('keydown', (e) => {
      if (e.repeat) return; 
      
      let dx = 0, dy = 0;
      const key = e.key.toLowerCase();
      
      if (e.key === 'ArrowUp') dy = -1;
      else if (e.key === 'ArrowDown') dy = 1;
      else if (e.key === 'ArrowLeft') dx = -1;
      else if (e.key === 'ArrowRight') dx = 1;
      else if (key === 'w') dy = -1;
      else if (key === 's') dy = 1;
      else if (key === 'a') dx = -1;
      else if (key === 'd') dx = 1;
      else if (key === 'i') dy = -1;
      else if (key === 'k') dy = 1;
      else if (key === 'j') dx = -1;
      else if (key === 'l') dx = 1;


      if (dx === 0 && dy === 0) return;
      
      const movementKeys = ['arrowup', 'arrowdown', 'arrowleft', 'arrowright', 'w', 'a', 's', 'd', 'i', 'j', 'k', 'l'];
      if (movementKeys.includes(key)) {
        e.preventDefault();
      }
      
      movePlayer(dx, dy);
    });

    canvas.addEventListener('touchstart', (e) => {
        if (e.touches.length > 1) return; 
        e.preventDefault();
        touchStartX = e.touches[0].clientX;
        touchStartY = e.touches[0].clientY;
    });

    canvas.addEventListener('touchend', (e) => {
        if (!e.changedTouches.length) return; 
        
        const touchEndX = e.changedTouches[0].clientX;
        const touchEndY = e.changedTouches[0].clientY;

        const dx = touchEndX - touchStartX;
        const dy = touchEndY - touchStartY;
        
        const threshold = 15; 
        
        if (Math.abs(dx) < threshold && Math.abs(dy) < threshold) {
            return;
        }

        if (Math.abs(dx) > Math.abs(dy)) {
            if (dx > 0) movePlayer(1, 0);
            else movePlayer(-1, 0);
        } else {
            if (dy > 0) movePlayer(0, 1);
            else movePlayer(0, -1);
        }
    });

    window.onclick = function(event) {
        const modal = document.getElementById('rule-modal');
        if (event.target == modal) {
            modal.style.display = "none";
        }
    }

    // --- åˆæœŸåŒ– ---
    initializeModes();
    resetGame();
  </script>
</body>
</html>